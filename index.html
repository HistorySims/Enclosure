<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Folk Village</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 100%);
    }
    #viewport {
      width: 100vw;
      height: 100vh;
      overflow-x: auto;
      overflow-y: hidden;
      cursor: grab;
      position: relative;
    }
    #viewport:active { cursor: grabbing; }
    #landscape-container {
      height: 100vh;
      width: 3000px;
      position: relative;
    }
    canvas {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #hud {
      position: fixed;
      left: 14px;
      top: 14px;
      z-index: 200;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(28,20,16,0.25);
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: bold;
      color: #1c1410;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      user-select: none;
      display: flex;
      gap: 16px;
    }
    #hud.bad { background: rgba(255,230,230,0.95); border-color: rgba(200,60,60,0.5); }
    .popup-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    .popup-overlay.show { display: block; }
    .hill-popup {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
      min-width: 260px;
      text-align: center;
    }
    .hill-popup.show { display: block; }
    .popup-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 12px;
      border-bottom: 2px solid #eee;
      padding-bottom: 8px;
    }
    .popup-info p { margin: 8px 0; }
    .popup-btn {
      display: block;
      width: 100%;
      margin: 8px 0;
      padding: 12px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    .popup-btn:hover { opacity: 0.9; }
    .popup-btn.build { background: #27ae60; color: white; }
    .popup-btn.clear { background: #e67e22; color: white; }
    .popup-btn.farm { background: #3498db; color: white; }
    .popup-btn.commons { background: #7CB342; color: white; }
    .popup-btn.close { background: #95a5a6; color: white; }
    #day-indicator {
      position: fixed;
      right: 14px; top: 14px;
      z-index: 200;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(28,20,16,0.25);
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>
  <div id="hud">
    <span>üí∞ $<span id="moneyVal">0</span></span>
    <span>üåæ <span id="foodVal">0</span></span>
    <span>üë• <span id="peasantVal">0</span></span>
  </div>
  <div id="day-indicator">Day <span id="dayVal">1</span></div>
  <div class="popup-overlay" id="popupOverlay"></div>
  <div class="hill-popup" id="hillPopup">
    <div class="popup-title" id="popupTitle">Hill</div>
    <div class="popup-info" id="popupInfo"></div>
  </div>
  <div id="viewport">
    <div id="landscape-container">
      <canvas id="gameCanvas" width="3000" height="800"></canvas>
    </div>
  </div>

<script>
const CANVAS_WIDTH = 3000, CANVAS_HEIGHT = 800, GROUND_Y = 800;
const SETTINGS = { numLines: 20, lineSpacing: 48, curveAmount: 20 };
const COSTS = { house: 20, clearLand: 100, buildFarm: 25, buildCommons: 25 };
const TASKS = { IDLE: 'idle', WALKING_TO_FIELD: 'walking_to_field', PLANTING: 'planting', HARVESTING: 'harvesting', TENDING_COMMONS: 'tending_commons', WALKING_HOME: 'walking_home' };
const CROP_STAGES = ['seed', 'growing', 'ready'];
const CROP_GROWTH_TIME = 450;
const NODE_SPACING_PX = 40; // Fixed pixel spacing between crop nodes

const game = { money: 50, food: 40, day: 1, dayTimer: 0, dayLength: 600, houses: {}, peasants: [] };
const sheepState = {};
let ctx;

// Only these hills show detailed content
const VISIBLE_HILLS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];

// Store all other hills that might occlude
const ALL_HILL_PATHS = {};

const hillConfigs = {
  1: { color: "#2D5016", peak: 144, start: -350, end: 600, type: "single", landType: "forest" },
  2: { color: "#2D5016", peak: 60, start: -150, end: 1000, type: "single", landType: "forest" },
  3: { color: "#8B7355", peak: 105, start: 350, end: 1550, type: "single", landType: "cleared" },
  4: { color: "#8B7355", peak: 75, start: 800, end: 1750, type: "single", landType: "cleared" },
  5: { color: "#2D5016", peak: 50, start: 1050, end: 2000, type: "single", landType: "forest" },
  6: { color: "#2D5016", peak: 72, start: 1500, end: 2750, type: "single", landType: "forest" },
  7: { color: "#2D5016", peak: 70, start: 2400, end: 3500, type: "single", landType: "forest" },
  8: { color: "#2D5016", peak: 245, start: -500, end: 1150, type: "single", landType: "forest" },
  9: { color: "#8B7355", peak: 198, start: 200, end: 1300, type: "single", landType: "cleared" },
  10: { color: "#7CB342", peak: 345, start: 600, end: 2050, type: "single", landType: "commons" },
  11: { color: "#6B5D3F", peak: 242, start: 750, end: 3500, type: "single", landType: "farm", cropType: "cabbage" },
  12: { color: "#6B5D3F", peak: 180, start: 1200, end: 2500, type: "single", landType: "farm", cropType: "wheat" },
  13: { color: "#8B7355", peak: 245, start: 1750, end: 3350, type: "single", landType: "cleared" },
  14: { color: "#2D5016", peak: 499, start: -50, end: 1200, type: "single", landType: "forest" },
  15: { color: "#2D5016", peak1: 700, peak2: 687, valley: 656, start: 500, end: 2000, type: "double", landType: "forest" },
  16: { color: "#2D5016", peak: 493, start: 2350, end: 3500, type: "single", landType: "forest" },
  17: { color: "#2D5016", peak1: 571, peak2: 609, valley: 631, start: 2300, end: 3050, type: "double", landType: "forest" },
  18: { color: "#2D5016", peak: 525, start: 1550, end: 2750, type: "single", landType: "forest" }
};

function clamp01(v) { return Math.max(0, Math.min(1, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function hash2(x, y) { const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123; return s - Math.floor(s); }

function updateUI() {
  document.getElementById('moneyVal').textContent = game.money;
  document.getElementById('foodVal').textContent = game.food;
  document.getElementById('peasantVal').textContent = game.peasants.length;
  document.getElementById('dayVal').textContent = game.day;
}

function flashHUD() {
  const hud = document.getElementById('hud');
  hud.classList.add('bad');
  setTimeout(() => hud.classList.remove('bad'), 200);
}

function spend(cost) {
  if (game.money < cost) { flashHUD(); return false; }
  game.money -= cost;
  updateUI();
  return true;
}

function getHillTop(config) {
  return typeof config.peak === 'number' ? config.peak : Math.min(config.peak1 || 9999, config.peak2 || 9999, config.valley || 9999);
}

const PEAK_STATS = (() => {
  let minP = Infinity, maxP = -Infinity;
  for (const k in hillConfigs) {
    const p = getHillTop(hillConfigs[k]);
    minP = Math.min(minP, p);
    maxP = Math.max(maxP, p);
  }
  return { minP, maxP };
})();

function depthOfHill(config) {
  const p = getHillTop(config);
  return clamp01((p - PEAK_STATS.minP) / (PEAK_STATS.maxP - PEAK_STATS.minP));
}

function generateHillPath(hillNum, config) {
  const { start, end, type } = config;
  if (type === "double") {
    const { peak1, peak2, valley } = config;
    const mid = (start + end) / 2;
    return `M ${start} ${GROUND_Y} C ${start + 50} ${GROUND_Y}, ${start + 100} ${peak1}, ${start + 200} ${peak1} C ${start + 250} ${peak1}, ${start + 275} ${valley}, ${mid} ${valley} C ${mid + 25} ${valley}, ${mid + 50} ${peak2}, ${end - 200} ${peak2} C ${end - 100} ${peak2}, ${end - 50} ${GROUND_Y}, ${end} ${GROUND_Y} Z`;
  }
  const { peak } = config;
  const mid = (start + end) / 2;
  const width = end - start;
  return `M ${start} ${GROUND_Y} C ${start + width * 0.1} ${GROUND_Y}, ${start + width * 0.3} ${peak}, ${mid} ${peak} C ${end - width * 0.3} ${peak}, ${end - width * 0.1} ${GROUND_Y}, ${end} ${GROUND_Y} Z`;
}

function getHillTopAnchor(hillNum, config) {
  const { start, end } = config;
  return { x: (start + end) / 2, y: getHillTop(config) - 18 };
}

// Check if point is occluded by any hill in front of the given hill
function isPointVisible(x, y, hillNum) {
  const thisHillTop = getHillTop(hillConfigs[hillNum]);
  for (const key in hillConfigs) {
    const otherTop = getHillTop(hillConfigs[key]);
    // Only check hills that are in front (higher peak value = closer to viewer)
    if (otherTop > thisHillTop) {
      const path = ALL_HILL_PATHS[key];
      if (path && ctx.isPointInPath(path, x, y)) {
        return false;
      }
    }
  }
  return true;
}

function setInk(w) {
  ctx.strokeStyle = "rgba(28, 20, 16, 0.95)";
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.lineWidth = Math.max(1, w);
}

function fillAndInk(fill) {
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.stroke();
}

function drawSprout(x, y, scale) {
  const s = scale * 18;
  setInk(s * 0.10);
  ctx.beginPath();
  ctx.ellipse(x, y, 0.45 * s, 0.22 * s, 0, 0, Math.PI * 2);
  fillAndInk("#6B4A2E");
  ctx.strokeStyle = "rgba(28,20,16,0.6)";
  ctx.lineWidth = Math.max(1, s * 0.07);
  ctx.beginPath();
  ctx.moveTo(x, y - 0.10 * s);
  ctx.lineTo(x, y - 0.65 * s);
  ctx.stroke();
  setInk(s * 0.09);
  ctx.beginPath();
  ctx.moveTo(x, y - 0.55 * s);
  ctx.quadraticCurveTo(x - 0.35 * s, y - 0.85 * s, x - 0.55 * s, y - 0.55 * s);
  ctx.closePath();
  fillAndInk("#7FCB73");
  ctx.beginPath();
  ctx.moveTo(x, y - 0.55 * s);
  ctx.quadraticCurveTo(x + 0.35 * s, y - 0.85 * s, x + 0.55 * s, y - 0.55 * s);
  ctx.closePath();
  fillAndInk("#6FAF64");
}

function drawCabbage(stage, x, y, scale) {
  const s = scale * 21;
  const jitter = (hash2(x, y) - 0.5) * s * 0.12;
  x += jitter;
  setInk(s * 0.10);
  if (stage === "seed") { drawSprout(x, y, scale); return; }
  if (stage === "growing") {
    ctx.beginPath();
    ctx.arc(x, y, 0.55 * s, 0, Math.PI * 2);
    fillAndInk("#66BB6A");
    return;
  }
  // Ready - round head
  ctx.beginPath();
  ctx.arc(x, y, 0.75 * s, 0, Math.PI * 2);
  fillAndInk("#4CAF50");
  ctx.beginPath();
  ctx.arc(x - 0.1 * s, y - 0.1 * s, 0.4 * s, 0, Math.PI * 2);
  fillAndInk("#81C784");
}

function drawWheat(stage, x, y, scale) {
  const s = scale * 21;
  const sway = (hash2(x, y) - 0.5) * 0.15;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(sway);
  setInk(s * 0.10);
  if (stage === "seed") { ctx.restore(); drawSprout(x, y, scale); return; }
  if (stage === "growing") {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -0.7 * s);
    ctx.strokeStyle = "#7CB342";
    ctx.lineWidth = Math.max(1, s * 0.08);
    ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(0, -0.8 * s, 0.15 * s, 0.2 * s, 0, 0, Math.PI * 2);
    fillAndInk("#C8A951");
    ctx.restore();
    return;
  }
  // Ready - golden stalk with round head
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -0.9 * s);
  ctx.strokeStyle = "#D4A940";
  ctx.lineWidth = Math.max(1, s * 0.08);
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(0, -1.0 * s, 0.2 * s, 0.28 * s, 0, 0, Math.PI * 2);
  fillAndInk("#E6C36A");
  ctx.restore();
}

function drawCrop(cropType, stage, x, y, scale) {
  if (cropType === "cabbage") drawCabbage(stage, x, y, scale);
  else drawWheat(stage, x, y, scale);
}

function drawSheep(x, y, scale, direction) {
  const s = scale * 15;
  setInk(s * 0.10);
  const facing = -(direction || 1);
  ctx.beginPath();
  ctx.ellipse(x, y, 0.55 * s, 0.40 * s, 0, 0, Math.PI * 2);
  fillAndInk("#F5F5F5");
  ctx.beginPath();
  ctx.ellipse(x - (0.45 * s * facing), y - 0.15 * s, 0.25 * s, 0.22 * s, 0, 0, Math.PI * 2);
  fillAndInk("#E8E8E8");
  ctx.strokeStyle = "rgba(28,20,16,0.8)";
  ctx.lineWidth = Math.max(1, s * 0.08);
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(x - 0.30 * s + i * 0.20 * s, y + 0.30 * s);
    ctx.lineTo(x - 0.30 * s + i * 0.20 * s, y + 0.55 * s);
    ctx.stroke();
  }
  ctx.fillStyle = "rgba(28,20,16,0.9)";
  ctx.beginPath();
  ctx.arc(x - (0.50 * s * facing), y - 0.18 * s, 0.04 * s, 0, Math.PI * 2);
  ctx.fill();
}

// Folk art tree - round canopy on dark trunk
function drawFolkTree(x, y, scale, variation) {
  const s = scale * 28;
  const v = variation || 0;
  setInk(Math.max(1, s * 0.08));
  // Trunk
  const trunkW = s * 0.12;
  const trunkH = s * (0.6 + v * 0.2);
  ctx.beginPath();
  ctx.moveTo(x - trunkW, y);
  ctx.lineTo(x - trunkW * 0.7, y - trunkH);
  ctx.lineTo(x + trunkW * 0.7, y - trunkH);
  ctx.lineTo(x + trunkW, y);
  ctx.closePath();
  fillAndInk("#3D2B1F");
  // Canopy - round blob like folk art
  const canopyColors = ["#2D5016", "#1E6B1E", "#3A7D32", "#2B6B2B"];
  const color = canopyColors[Math.floor(v * canopyColors.length) % canopyColors.length];
  const canopyR = s * (0.45 + v * 0.15);
  const canopyY = y - trunkH - canopyR * 0.6;
  ctx.beginPath();
  ctx.arc(x, canopyY, canopyR, 0, Math.PI * 2);
  fillAndInk(color);
  // Second smaller blob for variety
  if (v > 0.3) {
    const offX = (v - 0.5) * s * 0.3;
    ctx.beginPath();
    ctx.arc(x + offX, canopyY - canopyR * 0.3, canopyR * 0.6, 0, Math.PI * 2);
    fillAndInk(color);
  }
}

// Tree stump for cleared land
function drawStump(x, y, scale) {
  const s = scale * 18;
  setInk(Math.max(1, s * 0.10));
  // Stump body
  ctx.beginPath();
  ctx.moveTo(x - s * 0.2, y);
  ctx.lineTo(x - s * 0.15, y - s * 0.35);
  ctx.lineTo(x + s * 0.15, y - s * 0.35);
  ctx.lineTo(x + s * 0.2, y);
  ctx.closePath();
  fillAndInk("#5D4037");
  // Top of stump
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.35, s * 0.17, s * 0.07, 0, 0, Math.PI * 2);
  fillAndInk("#8D6E63");
}

// Generate tree/stump positions for a hill
const hillFeatures = {};
function generateHillFeatures(hillNum) {
  const config = hillConfigs[hillNum];
  const { start, end } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const hillPath = ALL_HILL_PATHS[hillNum];
  const depth = depthOfHill(config);
  const features = { trees: [], stumps: [] };

  if (config.landType === 'forest') {
    const numTrees = 12 + Math.floor(hash2(hillNum, 42) * 15);
    for (let i = 0; i < numTrees; i++) {
      const tx = start + width * (0.1 + hash2(i * 3, hillNum) * 0.8);
      const ty = GROUND_Y - hillHeight * (0.15 + hash2(i * 3 + 1, hillNum) * 0.7);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (1.0 - heightProgress * 0.35) * lerp(0.55, 1.2, depth);
        features.trees.push({ x: tx, y: ty, scale, variation: hash2(i + 200, hillNum) });
      }
    }
  } else if (config.landType === 'cleared') {
    const numStumps = 5 + Math.floor(hash2(hillNum, 55) * 6);
    for (let i = 0; i < numStumps; i++) {
      const tx = start + width * (0.15 + hash2(i * 7, hillNum + 10) * 0.7);
      const ty = GROUND_Y - hillHeight * (0.15 + hash2(i * 7 + 1, hillNum + 10) * 0.6);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (1.0 - heightProgress * 0.35) * lerp(0.55, 1.2, depth);
        features.stumps.push({ x: tx, y: ty, scale });
      }
    }
    // A few stray trees
    const numTrees = 2 + Math.floor(hash2(hillNum, 77) * 3);
    for (let i = 0; i < numTrees; i++) {
      const tx = start + width * (0.2 + hash2(i * 11, hillNum + 20) * 0.6);
      const ty = GROUND_Y - hillHeight * (0.2 + hash2(i * 11 + 1, hillNum + 20) * 0.5);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (0.8 - heightProgress * 0.3) * lerp(0.55, 1.2, depth);
        features.trees.push({ x: tx, y: ty, scale, variation: hash2(i + 300, hillNum) });
      }
    }
  }

  // Sort by y for depth ordering
  features.trees.sort((a, b) => a.y - b.y);
  features.stumps.sort((a, b) => a.y - b.y);
  return features;
}

function drawForestContent(hillNum, config) {
  if (!hillFeatures[hillNum]) hillFeatures[hillNum] = generateHillFeatures(hillNum);
  const features = hillFeatures[hillNum];
  for (const tree of features.trees) {
    drawFolkTree(tree.x, tree.y, tree.scale, tree.variation);
  }
}

function drawClearedContent(hillNum, config) {
  if (!hillFeatures[hillNum]) hillFeatures[hillNum] = generateHillFeatures(hillNum);
  const features = hillFeatures[hillNum];
  for (const stump of features.stumps) {
    drawStump(stump.x, stump.y, stump.scale);
  }
  for (const tree of features.trees) {
    drawFolkTree(tree.x, tree.y, tree.scale, tree.variation);
  }
}

function drawHouse(house) {
  const { x, y, s, windows, litCount, color, roofColor } = house;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((hash2(x, y) - 0.5) * 0.06);
  setInk(Math.max(1, s * 0.08));
  // Shadow
  ctx.beginPath();
  ctx.ellipse(0, s * 2.0, s * 1.6, s * 0.4, 0, 0, Math.PI * 2);
  fillAndInk("rgba(28,20,16,0.08)");
  // Main body - taller
  ctx.beginPath();
  ctx.rect(-s * 1.4, -s * 0.5, s * 2.8, s * 2.5);
  fillAndInk(color);
  // Steep roof
  ctx.beginPath();
  ctx.moveTo(-s * 1.6, -s * 0.5);
  ctx.lineTo(0, -s * 2.2);
  ctx.lineTo(s * 1.6, -s * 0.5);
  ctx.closePath();
  fillAndInk(roofColor);
  // Chimney
  ctx.beginPath();
  ctx.rect(s * 0.5, -s * 2.4, s * 0.4, s * 1.2);
  fillAndInk("#5D4037");
  ctx.beginPath();
  ctx.rect(s * 0.4, -s * 2.5, s * 0.6, s * 0.15);
  fillAndInk("#4E342E");
  // Door
  ctx.beginPath();
  ctx.rect(-s * 0.3, s * 0.7, s * 0.6, s * 1.3);
  fillAndInk("#5D4037");
  ctx.beginPath();
  ctx.arc(s * 0.2, s * 1.3, s * 0.06, 0, Math.PI * 2);
  fillAndInk("#F1D27E");
  // Windows with cross-panes
  const winW = s * 0.45, winH = s * 0.42;
  const slots = [
    { cx: -s * 0.75, cy: s * 0.15 },
    { cx: s * 0.75, cy: s * 0.15 },
    { cx: -s * 0.75, cy: s * 0.9 },
    { cx: s * 0.75, cy: s * 0.9 }
  ].slice(0, windows);
  for (let i = 0; i < slots.length; i++) {
    const lit = i < litCount;
    const sx = slots[i].cx, sy = slots[i].cy;
    ctx.beginPath();
    ctx.rect(sx - winW/2, sy - winH/2, winW, winH);
    fillAndInk("#EEE8DC");
    ctx.beginPath();
    ctx.rect(sx - winW/2 + s*0.05, sy - winH/2 + s*0.05, winW - s*0.10, winH - s*0.10);
    fillAndInk(lit ? "#F7D97C" : "#42505A");
    // Cross panes
    ctx.strokeStyle = "#EEE8DC";
    ctx.lineWidth = Math.max(1, s * 0.06);
    ctx.beginPath();
    ctx.moveTo(sx, sy - winH/2 + s*0.05);
    ctx.lineTo(sx, sy + winH/2 - s*0.05);
    ctx.moveTo(sx - winW/2 + s*0.05, sy);
    ctx.lineTo(sx + winW/2 - s*0.05, sy);
    ctx.stroke();
  }
  ctx.restore();
}

function drawPeasant(peasant, isShepherd = false) {
  const { x, y, direction } = peasant;
  const s = 32;
  ctx.save();
  if (direction === -1) {
    ctx.translate(x, y);
    ctx.scale(-1, 1);
    ctx.translate(-x, -y);
  }
  setInk(s * 0.10);
  // Body
  ctx.beginPath();
  ctx.arc(x, y, s * 0.35, 0, Math.PI * 2);
  fillAndInk("#8B6F47");
  // Head
  ctx.beginPath();
  ctx.arc(x, y - s * 0.45, s * 0.25, 0, Math.PI * 2);
  fillAndInk("#D4A574");
  // Hat
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.65, s * 0.30, s * 0.12, 0, 0, Math.PI * 2);
  fillAndInk("#6B4A2E");
  // Legs
  ctx.strokeStyle = "rgba(28,20,16,0.8)";
  ctx.lineWidth = Math.max(1, s * 0.10);
  ctx.beginPath();
  ctx.moveTo(x - s * 0.15, y + s * 0.30);
  ctx.lineTo(x - s * 0.15, y + s * 0.60);
  ctx.moveTo(x + s * 0.15, y + s * 0.30);
  ctx.lineTo(x + s * 0.15, y + s * 0.60);
  ctx.stroke();
  
  // Shepherd's crook/staff
  if (isShepherd) {
    ctx.strokeStyle = "#5D4037";
    ctx.lineWidth = Math.max(2, s * 0.08);
    ctx.beginPath();
    // Staff shaft
    ctx.moveTo(x + s * 0.35, y + s * 0.5);
    ctx.lineTo(x + s * 0.25, y - s * 0.8);
    // Crook curve at top
    ctx.quadraticCurveTo(x + s * 0.25, y - s * 1.1, x + s * 0.05, y - s * 1.0);
    ctx.stroke();
  }
  
  ctx.restore();
}

// House creation
function createHouse(hillNum, config) {
  const houses = game.houses[hillNum] || [];
  if (houses.length >= 5) return null;
  const anchor = getHillTopAnchor(hillNum, config);
  const depth = depthOfHill(config);
  const spread = (config.end - config.start) * 0.6;
  const offsetX = (houses.length - 2) * (spread / 5);
  const s = 20 + depth * 5;
  const bodyColors = ["#C0392B", "#FDFEFE", "#F5E6CA", "#C62828", "#ECEFF1"];
  const roofColors = ["#2B2B2E", "#3A2F2A", "#1F2A44", "#795548"];
  return {
    hillNum, x: anchor.x + offsetX, y: anchor.y, s,
    windows: 3 + Math.floor(Math.random() * 2),
    litCount: 0,
    color: bodyColors[Math.floor(Math.random() * bodyColors.length)],
    roofColor: roofColors[Math.floor(Math.random() * roofColors.length)]
  };
}

// Peasant creation
function createPeasant(houseHillNum, houseIdx) {
  const houses = game.houses[houseHillNum];
  if (!houses || !houses[houseIdx]) return null;
  const house = houses[houseIdx];
  return {
    id: Date.now() + Math.random(),
    homeHill: houseHillNum,
    houseIdx,
    x: house.x, y: house.y,
    targetX: house.x, targetY: house.y,
    task: TASKS.IDLE,
    taskData: {},
    speed: 0.8 + Math.random() * 0.4,
    idleTimer: 60,
    direction: 1,
    workHill: null,
    isShepherd: false
  };
}

function updatePeasantCount() {
  let totalCapacity = 0;
  for (const hillNum in game.houses) {
    totalCapacity += game.houses[hillNum].length * 2;
  }
  while (game.peasants.length < totalCapacity) {
    for (const hillNum in game.houses) {
      const houses = game.houses[hillNum];
      for (let hIdx = 0; hIdx < houses.length; hIdx++) {
        if (game.peasants.length >= totalCapacity) break;
        const peasant = createPeasant(parseInt(hillNum), hIdx);
        if (peasant) game.peasants.push(peasant);
      }
    }
  }
  if (game.peasants.length > totalCapacity) {
    game.peasants = game.peasants.slice(0, totalCapacity);
  }
  for (const hillNum in game.houses) {
    const houses = game.houses[hillNum];
    for (let hIdx = 0; hIdx < houses.length; hIdx++) {
      const count = game.peasants.filter(p => p.homeHill === parseInt(hillNum) && p.houseIdx === hIdx).length;
      houses[hIdx].litCount = Math.min(houses[hIdx].windows, Math.ceil(count / 1.5));
    }
  }
  updateUI();
}

// Generate visible nodes for a row at fixed pixel intervals
function generateRowNodes(hillNum, rowIdx) {
  const config = hillConfigs[hillNum];
  const { start, end } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const spacingMult = lerp(0.65, 1.45, depth);
  const effectiveNumLines = Math.round(clamp01(lerp(0.95, 1.10, 1 - depth)) * SETTINGS.numLines);
  const effectiveSpacing = SETTINGS.lineSpacing * spacingMult;
  const slope = (hillNum % 2 === 0) ? 1 : -1;
  const offset = (rowIdx - effectiveNumLines / 2) * effectiveSpacing;
  
  const hillPath = ALL_HILL_PATHS[hillNum];
  if (!hillPath) return [];
  
  // Sample many points along the line
  const allPoints = [];
  for (let seg = 0; seg <= 100; seg++) {
    const t = seg / 100;
    const x = start + width * t;
    const centerX = start + width / 2;
    const centerY = hillTop + hillHeight / 2;
    let y = slope * (x - centerX) + centerY + offset;
    if (SETTINGS.curveAmount > 0) {
      const distFromCenter = 1 - Math.abs(t - 0.5) * 2;
      y += distFromCenter * distFromCenter * SETTINGS.curveAmount * lerp(0.9, 1.15, depth);
    }
    allPoints.push({ x, y });
  }
  
  // Now pick nodes at fixed pixel intervals, only if visible
  const nodes = [];
  let distAccum = 0;
  let lastPoint = allPoints[0];
  
  for (let i = 1; i < allPoints.length; i++) {
    const p = allPoints[i];
    const dx = p.x - lastPoint.x;
    const dy = p.y - lastPoint.y;
    const segDist = Math.sqrt(dx * dx + dy * dy);
    distAccum += segDist;
    
    if (distAccum >= NODE_SPACING_PX) {
      // Check if this point is within the hill and visible (not occluded)
      if (ctx.isPointInPath(hillPath, p.x, p.y) && isPointVisible(p.x, p.y, hillNum)) {
        nodes.push({ x: p.x, y: p.y, hasCrop: false, crop: null });
      }
      distAccum = 0;
    }
    lastPoint = p;
  }
  
  return nodes;
}

// Initialize or get row nodes
function getRowNodes(hillNum, rowIdx) {
  const config = hillConfigs[hillNum];
  if (!config.rowNodes) config.rowNodes = {};
  if (!config.rowNodes[rowIdx]) {
    config.rowNodes[rowIdx] = generateRowNodes(hillNum, rowIdx);
  }
  return config.rowNodes[rowIdx];
}

function findWorkForPeasant(peasant) {
  const tasks = [];
  for (const key of VISIBLE_HILLS) {
    const config = hillConfigs[key];
    if (!config) continue;
    if (config.landType === 'farm' && config.rowOwnership) {
      for (let rowIdx = 0; rowIdx < config.rowOwnership.length; rowIdx++) {
        const nodes = getRowNodes(key, rowIdx);
        const emptyNodes = nodes.filter(n => !n.hasCrop);
        const readyNodes = nodes.filter(n => n.crop && n.crop.stage === 'ready');
        
        if (emptyNodes.length > 0) {
          tasks.push({ type: TASKS.PLANTING, hillNum: key, rowIdx, weight: 3 });
        }
        if (readyNodes.length > 0) {
          tasks.push({ type: TASKS.HARVESTING, hillNum: key, rowIdx, weight: 5 });
        }
      }
    } else if (config.landType === 'commons') {
      tasks.push({ type: TASKS.TENDING_COMMONS, hillNum: key, weight: 1 });
    }
  }
  
  if (tasks.length === 0) { goHome(peasant); return; }
  
  const totalWeight = tasks.reduce((sum, t) => sum + t.weight, 0);
  let rand = Math.random() * totalWeight;
  let chosen = tasks[0];
  for (const task of tasks) {
    rand -= task.weight;
    if (rand <= 0) { chosen = task; break; }
  }
  
  peasant.task = TASKS.WALKING_TO_FIELD;
  peasant.workHill = chosen.hillNum;
  peasant.isShepherd = (chosen.type === TASKS.TENDING_COMMONS);
  
  if (chosen.rowIdx !== undefined) {
    const nodes = getRowNodes(chosen.hillNum, chosen.rowIdx);
    let targetNodes;
    if (chosen.type === TASKS.PLANTING) {
      targetNodes = nodes.filter(n => !n.hasCrop);
    } else {
      targetNodes = nodes.filter(n => n.crop && n.crop.stage === 'ready');
    }
    
    if (targetNodes.length === 0) { findWorkForPeasant(peasant); return; }
    
    peasant.taskData = {
      hillNum: chosen.hillNum,
      rowIdx: chosen.rowIdx,
      taskType: chosen.type,
      nodeIndex: 0,
      nodes: targetNodes
    };
    
    peasant.targetX = targetNodes[0].x;
    peasant.targetY = targetNodes[0].y;
  } else {
    // Commons - find a visible spot
    const config = hillConfigs[chosen.hillNum];
    const hillPath = ALL_HILL_PATHS[chosen.hillNum];
    let targetX, targetY;
    let attempts = 0;
    do {
      targetX = config.start + (config.end - config.start) * (0.2 + Math.random() * 0.6);
      targetY = GROUND_Y - (GROUND_Y - getHillTop(config)) * (0.3 + Math.random() * 0.4);
      attempts++;
    } while (attempts < 20 && (!ctx.isPointInPath(hillPath, targetX, targetY) || !isPointVisible(targetX, targetY, chosen.hillNum)));
    
    peasant.taskData = { hillNum: chosen.hillNum, taskType: chosen.type };
    peasant.targetX = targetX;
    peasant.targetY = targetY;
  }
}

function goHome(peasant) {
  peasant.task = TASKS.WALKING_HOME;
  peasant.workHill = null;
  peasant.isShepherd = false;
  const houses = game.houses[peasant.homeHill];
  if (houses && houses[peasant.houseIdx]) {
    peasant.targetX = houses[peasant.houseIdx].x;
    peasant.targetY = houses[peasant.houseIdx].y;
  }
  peasant.taskData = {};
}

function updatePeasants() {
  for (const p of game.peasants) {
    const dx = p.targetX - p.x;
    const dy = p.targetY - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (Math.abs(dx) > 1) p.direction = dx > 0 ? 1 : -1;
    
    if (dist < 8) {
      handlePeasantArrival(p);
    } else {
      p.x += (dx / dist) * p.speed;
      p.y += (dy / dist) * p.speed;
    }
  }
  
  // Day cycle
  game.dayTimer++;
  if (game.dayTimer >= game.dayLength) {
    game.dayTimer = 0;
    game.day++;
    game.food -= game.peasants.length * 2;
    if (game.food < 0) game.food = 0;
    updateUI();
  }
}

function handlePeasantArrival(p) {
  switch (p.task) {
    case TASKS.WALKING_TO_FIELD:
      p.task = p.taskData.taskType;
      if (!p.taskData.nodes) {
        p.idleTimer = 120 + Math.random() * 180;
      }
      break;
      
    case TASKS.PLANTING:
      if (p.taskData.nodes) {
        const node = p.taskData.nodes[p.taskData.nodeIndex];
        // Plant immediately at this node
        if (node && !node.hasCrop) {
          node.hasCrop = true;
          node.crop = { stage: 'seed', growthTimer: 0 };
        }
        
        // Move to next node
        p.taskData.nodeIndex++;
        if (p.taskData.nodeIndex >= p.taskData.nodes.length) {
          findWorkForPeasant(p);
        } else {
          const nextNode = p.taskData.nodes[p.taskData.nodeIndex];
          p.targetX = nextNode.x;
          p.targetY = nextNode.y;
        }
      }
      break;
      
    case TASKS.HARVESTING:
      if (p.taskData.nodes) {
        const node = p.taskData.nodes[p.taskData.nodeIndex];
        // Harvest immediately at this node
        if (node && node.crop && node.crop.stage === 'ready') {
          const config = hillConfigs[p.taskData.hillNum];
          const rowOwner = config.rowOwnership[p.taskData.rowIdx];
          if (rowOwner === 'player') game.money += 1;
          else game.food += 2;
          node.hasCrop = false;
          node.crop = null;
          updateUI();
        }
        
        // Move to next node
        p.taskData.nodeIndex++;
        if (p.taskData.nodeIndex >= p.taskData.nodes.length) {
          findWorkForPeasant(p);
        } else {
          const nextNode = p.taskData.nodes[p.taskData.nodeIndex];
          p.targetX = nextNode.x;
          p.targetY = nextNode.y;
        }
      }
      break;
      
    case TASKS.TENDING_COMMONS:
      p.idleTimer--;
      if (p.idleTimer <= 0) {
        game.food += 2;
        updateUI();
        findWorkForPeasant(p);
      }
      break;
      
    case TASKS.WALKING_HOME:
      p.task = TASKS.IDLE;
      p.idleTimer = 60 + Math.random() * 120;
      break;
      
    case TASKS.IDLE:
      p.idleTimer--;
      if (p.idleTimer <= 0) findWorkForPeasant(p);
      break;
  }
}

// Sheep
function initializeSheep(hillNum, config) {
  const { start, end } = config;
  const width = end - start;
  const numSheep = 8 + Math.floor(hash2(hillNum, 999) * 8);
  const sheep = [];
  for (let i = 0; i < numSheep; i++) {
    sheep.push({
      x: start + width * (0.2 + hash2(i, hillNum) * 0.6),
      yProgress: 0.3 + hash2(i + 100, hillNum) * 0.4,
      speed: 0.3 + hash2(i + 500, hillNum) * 0.4,
      direction: hash2(i + 1000, hillNum) > 0.5 ? 1 : -1,
      bounds: { start: start + 100, end: end - 100 }
    });
  }
  return sheep;
}

function updateSheep(sheep) {
  for (const s of sheep) {
    s.x += s.direction * s.speed;
    if (s.x < s.bounds.start || s.x > s.bounds.end) s.direction *= -1;
  }
}

// Crop growth
function updateCropGrowth() {
  for (const key of VISIBLE_HILLS) {
    const config = hillConfigs[key];
    if (!config || config.landType !== 'farm' || !config.rowNodes) continue;
    for (const rowIdx in config.rowNodes) {
      for (const node of config.rowNodes[rowIdx]) {
        if (!node.crop || node.crop.stage === 'ready') continue;
        node.crop.growthTimer++;
        if (node.crop.growthTimer >= CROP_GROWTH_TIME) {
          node.crop.growthTimer = 0;
          const stageIdx = CROP_STAGES.indexOf(node.crop.stage);
          if (stageIdx < CROP_STAGES.length - 1) {
            node.crop.stage = CROP_STAGES[stageIdx + 1];
          }
        }
      }
    }
  }
}

// Farm initialization
function initializeFarmHill(config) {
  const effectiveNumLines = Math.round(SETTINGS.numLines);
  config.rowOwnership = [];
  config.rowNodes = null; // Will be generated on first access
  for (let i = 0; i < effectiveNumLines; i++) {
    config.rowOwnership.push(Math.random() < 0.33 ? "peasant" : "player");
  }
}

// Drawing content
function drawFarmContent(hillNum, config) {
  if (!config.rowOwnership) return;
  
  const { start, end, cropType } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const spacingMult = lerp(0.65, 1.45, depth);
  const cropSizeMult = lerp(0.70, 1.35, depth);
  const effectiveNumLines = Math.round(clamp01(lerp(0.95, 1.10, 1 - depth)) * SETTINGS.numLines);
  const effectiveSpacing = SETTINGS.lineSpacing * spacingMult;
  const slope = (hillNum % 2 === 0) ? 1 : -1;
  const hillPath = ALL_HILL_PATHS[hillNum];

  // Draw row lines
  for (let lineIdx = 0; lineIdx < effectiveNumLines; lineIdx++) {
    const offset = (lineIdx - effectiveNumLines / 2) * effectiveSpacing;
    const owner = config.rowOwnership[lineIdx] || "player";
    
    ctx.save();
    ctx.clip(hillPath);
    ctx.strokeStyle = owner === "player" ? "rgba(28,20,16,0.70)" : "rgba(139,111,78,0.60)";
    ctx.lineWidth = lerp(1.2, 2.2, depth);
    ctx.beginPath();
    
    for (let seg = 0; seg <= 60; seg++) {
      const t = seg / 60;
      const x = start + width * t;
      const centerX = start + width / 2;
      const centerY = hillTop + hillHeight / 2;
      let y = slope * (x - centerX) + centerY + offset;
      if (SETTINGS.curveAmount > 0) {
        const distFromCenter = 1 - Math.abs(t - 0.5) * 2;
        y += distFromCenter * distFromCenter * SETTINGS.curveAmount * lerp(0.9, 1.15, depth);
      }
      if (seg === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
    
    // Draw crops at nodes
    const nodes = getRowNodes(hillNum, lineIdx);
    for (const node of nodes) {
      if (node.crop) {
        const heightProgress = clamp01((GROUND_Y - node.y) / Math.max(1, hillHeight));
        const scale = (1.05 - heightProgress * 0.35) * cropSizeMult;
        drawCrop(cropType || 'wheat', node.crop.stage, node.x, node.y, scale);
      }
    }
  }
}

function drawCommonsContent(hillNum, config) {
  const hillPath = ALL_HILL_PATHS[hillNum];
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const sheep = sheepState[hillNum] || [];
  
  for (const s of sheep) {
    const y = GROUND_Y - hillHeight * s.yProgress;
    if (!ctx.isPointInPath(hillPath, s.x, y)) continue;
    if (!isPointVisible(s.x, y, hillNum)) continue;
    const heightProgress = clamp01((GROUND_Y - y) / Math.max(1, hillHeight));
    const scale = (1.05 - heightProgress * 0.35) * lerp(0.70, 1.35, depth);
    drawSheep(s.x, y, scale, s.direction);
  }
}

// Main render
function render() {
  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  const skyGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
  skyGradient.addColorStop(0, "#87CEEB");
  skyGradient.addColorStop(1, "#B0E0E6");
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  // Sort hills by depth (back to front)
  const keys = Object.keys(hillConfigs).map(n => parseInt(n, 10));
  keys.sort((a, b) => getHillTop(hillConfigs[a]) - getHillTop(hillConfigs[b]));

  for (const i of keys) {
    const config = hillConfigs[i];
    ctx.fillStyle = config.color;
    const path = ALL_HILL_PATHS[i];
    ctx.fill(path);
    ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
    ctx.lineWidth = 2;
    ctx.stroke(path);

    // Only draw content on visible hills
    if (VISIBLE_HILLS.includes(i)) {
      switch (config.landType) {
        case "farm": drawFarmContent(i, config); break;
        case "commons": drawCommonsContent(i, config); break;
        case "forest": drawForestContent(i, config); break;
        case "cleared": drawClearedContent(i, config); break;
      }
      if (game.houses[i]) {
        for (const house of game.houses[i]) drawHouse(house);
      }
    }
  }

  // Draw peasants
  for (const peasant of game.peasants) {
    if (isPointVisible(peasant.x, peasant.y, peasant.workHill || peasant.homeHill)) {
      drawPeasant(peasant, peasant.isShepherd);
    }
  }
}

// Game loop
function gameLoop() {
  for (const key in sheepState) updateSheep(sheepState[key]);
  updatePeasants();
  updateCropGrowth();
  render();
  requestAnimationFrame(gameLoop);
}

// Popup
function showPopup(hillNum) {
  const config = hillConfigs[hillNum];
  const popup = document.getElementById('hillPopup');
  const overlay = document.getElementById('popupOverlay');
  const title = document.getElementById('popupTitle');
  const info = document.getElementById('popupInfo');
  const houseCount = (game.houses[hillNum] || []).length;
  const landNames = { farm: 'Farm', commons: 'Commons', forest: 'Forest', cleared: 'Cleared Land' };
  title.textContent = `Hill ${hillNum} - ${landNames[config.landType] || config.landType}`;
  let html = `<p>üè† Houses: ${houseCount}/5</p>`;
  if (VISIBLE_HILLS.includes(hillNum)) {
    if (houseCount < 5) html += `<button class="popup-btn build" onclick="buildCottage(${hillNum})">Build Cottage ($${COSTS.house})</button>`;
    if (config.landType === 'forest') html += `<button class="popup-btn clear" onclick="clearLand(${hillNum})">Clear Land ($${COSTS.clearLand})</button>`;
    if (config.landType === 'cleared') {
      html += `<button class="popup-btn farm" onclick="buildFarm(${hillNum})">Build Farm ($${COSTS.buildFarm})</button>`;
      html += `<button class="popup-btn commons" onclick="buildCommons(${hillNum})">Make Commons ($${COSTS.buildCommons})</button>`;
    }
  } else {
    html += `<p><em>This hill is too far away</em></p>`;
  }
  html += `<button class="popup-btn close" onclick="closePopup()">Close</button>`;
  info.innerHTML = html;
  popup.classList.add('show');
  overlay.classList.add('show');
}

function closePopup() {
  document.getElementById('hillPopup').classList.remove('show');
  document.getElementById('popupOverlay').classList.remove('show');
}

window.buildCottage = function(hillNum) {
  if (!spend(COSTS.house)) return;
  if (!game.houses[hillNum]) game.houses[hillNum] = [];
  if (game.houses[hillNum].length >= 5) return;
  const house = createHouse(hillNum, hillConfigs[hillNum]);
  if (house) {
    game.houses[hillNum].push(house);
    updatePeasantCount();
  }
  closePopup();
};

window.clearLand = function(hillNum) {
  if (!spend(COSTS.clearLand)) return;
  hillConfigs[hillNum].landType = 'cleared';
  hillConfigs[hillNum].color = '#8B7355';
  closePopup();
};

window.buildFarm = function(hillNum) {
  if (!spend(COSTS.buildFarm)) return;
  hillConfigs[hillNum].landType = 'farm';
  hillConfigs[hillNum].color = '#6B5D3F';
  hillConfigs[hillNum].cropType = 'wheat';
  initializeFarmHill(hillConfigs[hillNum]);
  closePopup();
};

window.buildCommons = function(hillNum) {
  if (!spend(COSTS.buildCommons)) return;
  hillConfigs[hillNum].landType = 'commons';
  hillConfigs[hillNum].color = '#7CB342';
  sheepState[hillNum] = initializeSheep(hillNum, hillConfigs[hillNum]);
  closePopup();
};

window.closePopup = closePopup;

// Input
function setupInput() {
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('gameCanvas');
  let isDown = false, startX = 0, scrollLeft = 0, hasMoved = false;

  viewport.addEventListener('mousedown', (e) => {
    isDown = true;
    hasMoved = false;
    startX = e.pageX - viewport.offsetLeft;
    scrollLeft = viewport.scrollLeft;
  });
  viewport.addEventListener('mouseleave', () => { isDown = false; });
  viewport.addEventListener('mouseup', () => { isDown = false; });
  viewport.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    hasMoved = true;
    viewport.scrollLeft = scrollLeft - (e.pageX - viewport.offsetLeft - startX) * 2;
  });

  canvas.addEventListener('click', (e) => {
    if (hasMoved) return;
    const rect = canvas.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
    const keys = Object.keys(hillConfigs).map(n => parseInt(n, 10));
    keys.sort((a, b) => getHillTop(hillConfigs[b]) - getHillTop(hillConfigs[a]));
    for (const i of keys) {
      if (ctx.isPointInPath(ALL_HILL_PATHS[i], canvasX, canvasY)) {
        showPopup(i);
        return;
      }
    }
  });

  document.getElementById('popupOverlay').addEventListener('click', closePopup);
}

// Init
function init() {
  const canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  
  // Pre-generate all hill paths
  for (const key in hillConfigs) {
    ALL_HILL_PATHS[key] = new Path2D(generateHillPath(parseInt(key), hillConfigs[key]));
  }

  for (const key in hillConfigs) {
    const config = hillConfigs[key];
    if (config.landType === 'farm') initializeFarmHill(config);
    if (config.landType === 'commons') sheepState[key] = initializeSheep(parseInt(key), config);
  }

  // Starter houses
  for (const hillNum of [11]) {
    if (!VISIBLE_HILLS.includes(hillNum)) continue;
    if (!game.houses[hillNum]) game.houses[hillNum] = [];
    const house = createHouse(hillNum, hillConfigs[hillNum]);
    if (house) game.houses[hillNum].push(house);
  }

  updatePeasantCount();
  updateUI();
  setupInput();

  const viewport = document.getElementById('viewport');
  viewport.scrollLeft = (viewport.scrollWidth - viewport.clientWidth) / 2;

  gameLoop();
}

window.addEventListener('load', init);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Folk Village</title>
  <style>
    :root {
      --color-ink: rgba(28, 20, 16, 0.95);
      --color-ink-light: rgba(28, 20, 16, 0.25);
      --color-brown-dark: #5D4037;
      --color-brown-medium: #8B7355;
      --color-brown-light: #8D6E63;
      --color-farm: #6B5D3F;
      --color-fallow: #9E8E6E;
      --color-forest: #2D5016;
      --color-commons: #7CB342;
      --color-cleared: #8B7355;
      --color-sky-top: #87CEEB;
      --color-sky-bottom: #B0E0E6;
      --color-health-good: #4CAF50;
      --color-health-warn: #FF9800;
      --color-health-bad: #F44336;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(to bottom, var(--color-sky-top) 0%, var(--color-sky-bottom) 100%);
    }
    #viewport {
      width: 100vw;
      height: 100vh;
      overflow-x: auto;
      overflow-y: hidden;
      cursor: grab;
      position: relative;
    }
    #viewport:active { cursor: grabbing; }
    #landscape-container {
      height: 100vh;
      width: 3000px;
      position: relative;
    }
    canvas {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #hud {
      position: fixed;
      left: 14px;
      top: 14px;
      z-index: 200;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(28,20,16,0.25);
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: bold;
      color: #1c1410;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      user-select: none;
      display: flex;
      gap: 16px;
    }
    #hud.bad { background: rgba(255,230,230,0.95); border-color: rgba(200,60,60,0.5); }
    #hud.hidden { display: none; }
    .popup-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    .popup-overlay.show { display: block; }
    .hill-popup {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
      min-width: 260px;
      text-align: center;
    }
    .hill-popup.show { display: block; }
    .popup-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 12px;
      border-bottom: 2px solid #eee;
      padding-bottom: 8px;
    }
    .popup-info p { margin: 8px 0; }
    .popup-btn {
      display: block;
      width: 100%;
      margin: 8px 0;
      padding: 12px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    .popup-btn:hover { opacity: 0.9; }
    .popup-btn.build { background: #27ae60; color: white; }
    .popup-btn.clear { background: #e67e22; color: white; }
    .popup-btn.farm { background: #3498db; color: white; }
    .popup-btn.commons { background: #7CB342; color: white; }
    .popup-btn.close { background: #95a5a6; color: white; }
    #game-log {
      position: fixed;
      bottom: 14px;
      left: 14px;
      z-index: 200;
      max-width: 400px;
      pointer-events: none;
    }
    .log-msg {
      background: rgba(255,255,255,0.85);
      border-radius: 6px;
      padding: 6px 12px;
      margin-top: 4px;
      font-size: 12px;
      color: #1c1410;
      animation: logFade 5s ease-out forwards;
    }
    @keyframes logFade {
      0%, 70% { opacity: 1; }
      100% { opacity: 0; }
    }
    #day-indicator {
      position: fixed;
      right: 14px; top: 14px;
      z-index: 200;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(28,20,16,0.25);
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    #day-indicator.hidden { display: none; }
    #title-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(to bottom, var(--color-sky-top) 0%, var(--color-sky-bottom) 100%);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 40px 20px 60px;
      box-sizing: border-box;
      overflow-y: auto;
      font-family: Georgia, serif;
    }
    #title-screen.hidden { display: none; }
    #title-screen h1 {
      font-size: 72px;
      color: var(--color-brown-dark);
      text-shadow: 3px 3px 0 rgba(255,255,255,0.5);
      margin-bottom: 10px;
    }
    #title-screen .subtitle {
      font-size: 20px;
      color: #5D4037;
      margin-bottom: 40px;
      font-style: italic;
    }
    #title-screen .how-to-play {
      background: rgba(255,255,255,0.92);
      border: 2px solid var(--color-ink-light);
      border-radius: 16px;
      padding: 24px 32px;
      max-width: 600px;
      text-align: left;
      margin-bottom: 30px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.15);
    }
    #title-screen .how-to-play h2 {
      text-align: center;
      margin-bottom: 16px;
      color: var(--color-brown-dark);
      border-bottom: 2px solid #eee;
      padding-bottom: 8px;
    }
    #title-screen .how-to-play ul {
      margin: 0;
      padding-left: 20px;
      line-height: 1.8;
      color: #333;
    }
    #title-screen .how-to-play li {
      margin-bottom: 8px;
    }
    #title-screen .start-btn {
      background: var(--color-health-good);
      color: white;
      border: none;
      padding: 16px 48px;
      font-size: 24px;
      font-family: Georgia, serif;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: transform 0.1s, box-shadow 0.1s;
    }
    #title-screen .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
    }
  </style>
</head>
<body>
  <div id="title-screen">
    <h1>Folk Village</h1>
    <p class="subtitle">A game of land, labour, and enclosure</p>
    <div class="how-to-play">
      <h2>How to Play</h2>
      <ul>
        <li><strong>Click on hills</strong> to build cottages, clear forests, create farms and commons</li>
        <li><strong>Peasants</strong> automatically work the land ‚Äî they plant, harvest, and tend sheep</li>
        <li><strong>Farms</strong> produce money (your rows) or food (peasant rows)</li>
        <li><strong>Commons</strong> let peasants graze sheep for food</li>
        <li><strong>Rotate crops</strong> to restore soil health ‚Äî turnips restore 90%!</li>
        <li><strong>Keep food above zero</strong> or peasants will leave</li>
        <li>At <strong>Day 40</strong>: Turnips unlock with better soil restoration</li>
        <li>At <strong>Day 80</strong>: Seed drills let you mechanize farming</li>
        <li>At <strong>Day 120</strong>: The Enclosure Acts let you claim the commons...</li>
      </ul>
    </div>
    <button class="start-btn" onclick="startGame()">Begin</button>
  </div>
  <div id="hud" class="hidden">
    <span>üí∞ ¬£<span id="moneyVal">0</span></span>
    <span>üçû Stores: <span id="foodVal">0</span></span>
    <span>üë• <span id="peasantVal">0</span>/<span id="capacityVal">0</span></span>
  </div>
  <div id="day-indicator" class="hidden">Day <span id="dayVal">1</span></div>
  <div class="popup-overlay" id="popupOverlay"></div>
  <div class="hill-popup" id="hillPopup">
    <div class="popup-title" id="popupTitle">Hill</div>
    <div class="popup-info" id="popupInfo"></div>
  </div>
  <div id="viewport">
    <div id="landscape-container">
      <canvas id="gameCanvas" width="3000" height="800"></canvas>
    </div>
  </div>
  <div id="game-log"></div>

<script>
const CANVAS_WIDTH = 3000, CANVAS_HEIGHT = 800, GROUND_Y = 800;
const SETTINGS = { numLines: 20, lineSpacing: 48, curveAmount: 20, rowsPerPx: 0.015 };
const COSTS = { house: 20, clearLand: 100, buildFarm: 25, buildCommons: 25, machine: 40, encloseField: 25, demolishReward: 10 };
const TASKS = { IDLE: 'idle', WALKING_TO_FIELD: 'walking_to_field', PLANTING: 'planting', HARVESTING: 'harvesting', TENDING_COMMONS: 'tending_commons', WALKING_HOME: 'walking_home' };
const CROP_STAGES = ['seed', 'growing', 'ready'];

/** Game constants - centralizes magic numbers for easier tuning */
const GC = {
  // Timing
  CROP_GROWTH_TIME: 200,
  CROP_ROT_TIME: 3000,
  ROTTEN_REMOVAL_TIME: 200,
  DAY_LENGTH: 600,
  FALLOW_DAYS: 10,
  // Movement
  ARRIVAL_THRESHOLD: 8,
  PEASANT_SPEED_MIN: 0.8,
  PEASANT_SPEED_MAX: 1.2,
  MACHINE_SPEED: 2.0,
  // Idle timers
  PEASANT_IDLE_MIN: 60,
  PEASANT_IDLE_MAX: 180,
  MACHINE_IDLE_MIN: 30,
  MACHINE_IDLE_MAX: 90,
  COMMONS_WORK_TIME: 120,
  // Spacing
  NODE_SPACING_PX: 40,
  // Yields
  COMMONS_FOOD_YIELD: 12,
  FOOD_PER_PEASANT: 2,
  PEASANTS_PER_HOUSE: 2,
  MAX_HOUSES_PER_HILL: 5,
  // Desperate mode threshold
  DESPERATE_PEASANT_COUNT: 6,
  // Repopulation
  MAX_PEASANTS_PER_DAY: 3,
  // Animation
  MOVEMENT_LERP_SPEED: 0.15
};

const game = { money: 50, food: 100, day: 1, dayTimer: 0, dayLength: GC.DAY_LENGTH, houses: {}, peasants: [], machines: [], turnipsUnlocked: false, mechanicsUnlocked: false, enclosureUnlocked: false };
const sheepState = {};
const floaters = [];
let ctx;

/** Cached DOM element references for performance */
const DOM = {};

/** Cached sorted hill keys (back to front) for rendering */
let sortedHillKeys = [];

// Only these hills show detailed content
const VISIBLE_HILLS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];

// Store all other hills that might occlude
const ALL_HILL_PATHS = {};

const hillConfigs = {
  1: { color: "#2D5016", peak: 144, start: -350, end: 600, type: "single", landType: "forest" },
  2: { color: "#2D5016", peak: 60, start: -150, end: 1000, type: "single", landType: "forest" },
  3: { color: "#8B7355", peak: 105, start: 350, end: 1550, type: "single", landType: "cleared" },
  4: { color: "#8B7355", peak: 75, start: 800, end: 1750, type: "single", landType: "cleared" },
  5: { color: "#2D5016", peak: 50, start: 1050, end: 2000, type: "single", landType: "forest" },
  6: { color: "#2D5016", peak: 72, start: 1500, end: 2750, type: "single", landType: "forest" },
  7: { color: "#2D5016", peak: 70, start: 2400, end: 3500, type: "single", landType: "forest" },
  8: { color: "#2D5016", peak: 245, start: -500, end: 1150, type: "single", landType: "forest" },
  9: { color: "#8B7355", peak: 198, start: 200, end: 1300, type: "single", landType: "cleared" },
  10: { color: "#7CB342", peak: 345, start: 600, end: 2050, type: "single", landType: "commons" },
  11: { color: "#6B5D3F", peak: 242, start: 750, end: 3500, type: "single", landType: "farm", cropType: "cabbage" },
  12: { color: "#6B5D3F", peak: 180, start: 1200, end: 2500, type: "single", landType: "farm", cropType: "wheat" },
  13: { color: "#8B7355", peak: 245, start: 1750, end: 3350, type: "single", landType: "cleared" },
  14: { color: "#2D5016", peak: 499, start: -50, end: 1200, type: "single", landType: "forest" },
  15: { color: "#2D5016", peak1: 700, peak2: 687, valley: 656, start: 500, end: 2000, type: "double", landType: "forest" },
  16: { color: "#2D5016", peak: 493, start: 2350, end: 3500, type: "single", landType: "forest" },
  17: { color: "#2D5016", peak1: 571, peak2: 609, valley: 631, start: 2300, end: 3050, type: "double", landType: "forest" },
  18: { color: "#2D5016", peak: 525, start: 1550, end: 2750, type: "single", landType: "forest" }
};

function clamp01(v) { return Math.max(0, Math.min(1, v)); }
function getNumRows(config) { return Math.max(SETTINGS.numLines, Math.round((config.end - config.start) * SETTINGS.rowsPerPx)); }
function getYieldBonus() { return Math.min(4, 1 + Math.floor(game.day / 20)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function hash2(x, y) { const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123; return s - Math.floor(s); }

/** Calculates total house capacity for peasants */
function getHouseCapacity() {
  let capacity = 0;
  for (const hillNum in game.houses) {
    capacity += game.houses[hillNum].length * GC.PEASANTS_PER_HOUSE;
  }
  return capacity;
}

/** Updates the HUD display with current game values */
function updateUI() {
  DOM.moneyVal.textContent = game.money;
  DOM.foodVal.textContent = game.food;
  DOM.peasantVal.textContent = game.peasants.length;
  DOM.capacityVal.textContent = getHouseCapacity();
  DOM.dayVal.textContent = game.day;
}

/** Flashes the HUD red briefly to indicate insufficient funds */
function flashHUD() {
  DOM.hud.classList.add('bad');
  setTimeout(() => DOM.hud.classList.remove('bad'), 200);
}

function spend(cost) {
  if (game.money < cost) { flashHUD(); return false; }
  game.money -= cost;
  updateUI();
  return true;
}

function getHillTop(config) {
  return typeof config.peak === 'number' ? config.peak : Math.min(config.peak1 || 9999, config.peak2 || 9999, config.valley || 9999);
}

const PEAK_STATS = (() => {
  let minP = Infinity, maxP = -Infinity;
  for (const k in hillConfigs) {
    const p = getHillTop(hillConfigs[k]);
    minP = Math.min(minP, p);
    maxP = Math.max(maxP, p);
  }
  return { minP, maxP };
})();

function depthOfHill(config) {
  const p = getHillTop(config);
  return clamp01((p - PEAK_STATS.minP) / (PEAK_STATS.maxP - PEAK_STATS.minP));
}

function generateHillPath(hillNum, config) {
  const { start, end, type } = config;
  if (type === "double") {
    const { peak1, peak2, valley } = config;
    const mid = (start + end) / 2;
    return `M ${start} ${GROUND_Y} C ${start + 50} ${GROUND_Y}, ${start + 100} ${peak1}, ${start + 200} ${peak1} C ${start + 250} ${peak1}, ${start + 275} ${valley}, ${mid} ${valley} C ${mid + 25} ${valley}, ${mid + 50} ${peak2}, ${end - 200} ${peak2} C ${end - 100} ${peak2}, ${end - 50} ${GROUND_Y}, ${end} ${GROUND_Y} Z`;
  }
  const { peak } = config;
  const mid = (start + end) / 2;
  const width = end - start;
  return `M ${start} ${GROUND_Y} C ${start + width * 0.1} ${GROUND_Y}, ${start + width * 0.3} ${peak}, ${mid} ${peak} C ${end - width * 0.3} ${peak}, ${end - width * 0.1} ${GROUND_Y}, ${end} ${GROUND_Y} Z`;
}

function getHillTopAnchor(hillNum, config) {
  const { start, end } = config;
  return { x: (start + end) / 2, y: getHillTop(config) - 18 };
}

/**
 * Check if point is occluded by any hill in front of the given hill.
 * Uses bounding box pre-check for performance before expensive isPointInPath.
 */
function isPointVisible(x, y, hillNum) {
  const thisHillTop = getHillTop(hillConfigs[hillNum]);
  for (const key in hillConfigs) {
    const otherConfig = hillConfigs[key];
    const otherTop = getHillTop(otherConfig);
    // Only check hills that are in front (higher peak value = closer to viewer)
    if (otherTop > thisHillTop) {
      // Bounding box pre-check (fast rejection)
      if (x < otherConfig.start || x > otherConfig.end) continue;
      if (y < otherTop || y > GROUND_Y) continue;

      // Expensive path check only if within bounding box
      const path = ALL_HILL_PATHS[key];
      if (path && ctx.isPointInPath(path, x, y)) {
        return false;
      }
    }
  }
  return true;
}

function setInk(w) {
  ctx.strokeStyle = "rgba(28, 20, 16, 0.95)";
  ctx.lineJoin = "round";
  ctx.lineCap = "round";
  ctx.lineWidth = Math.max(1, w);
}

function fillAndInk(fill) {
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.stroke();
}

function drawSprout(x, y, scale) {
  const s = scale * 18;
  setInk(s * 0.10);
  ctx.beginPath();
  ctx.ellipse(x, y, 0.45 * s, 0.22 * s, 0, 0, Math.PI * 2);
  fillAndInk("#6B4A2E");
  ctx.strokeStyle = "rgba(28,20,16,0.6)";
  ctx.lineWidth = Math.max(1, s * 0.07);
  ctx.beginPath();
  ctx.moveTo(x, y - 0.10 * s);
  ctx.lineTo(x, y - 0.65 * s);
  ctx.stroke();
  setInk(s * 0.09);
  ctx.beginPath();
  ctx.moveTo(x, y - 0.55 * s);
  ctx.quadraticCurveTo(x - 0.35 * s, y - 0.85 * s, x - 0.55 * s, y - 0.55 * s);
  ctx.closePath();
  fillAndInk("#7FCB73");
  ctx.beginPath();
  ctx.moveTo(x, y - 0.55 * s);
  ctx.quadraticCurveTo(x + 0.35 * s, y - 0.85 * s, x + 0.55 * s, y - 0.55 * s);
  ctx.closePath();
  fillAndInk("#6FAF64");
}

function drawCabbage(stage, x, y, scale) {
  const s = scale * 21;
  const jitter = (hash2(x, y) - 0.5) * s * 0.12;
  x += jitter;
  setInk(s * 0.10);
  if (stage === "seed") { drawSprout(x, y, scale); return; }
  if (stage === "growing") {
    ctx.beginPath();
    ctx.arc(x, y, 0.55 * s, 0, Math.PI * 2);
    fillAndInk("#66BB6A");
    return;
  }
  if (stage === "rotten") {
    ctx.beginPath();
    ctx.arc(x, y, 0.6 * s, 0, Math.PI * 2);
    fillAndInk("#8B7355");
    ctx.beginPath();
    ctx.arc(x, y, 0.35 * s, 0, Math.PI * 2);
    fillAndInk("#6B5D3F");
    return;
  }
  // Ready - round head
  ctx.beginPath();
  ctx.arc(x, y, 0.75 * s, 0, Math.PI * 2);
  fillAndInk("#4CAF50");
  ctx.beginPath();
  ctx.arc(x - 0.1 * s, y - 0.1 * s, 0.4 * s, 0, Math.PI * 2);
  fillAndInk("#81C784");
}

function drawWheat(stage, x, y, scale) {
  const s = scale * 21;
  setInk(s * 0.08);
  if (stage === "seed") { drawSprout(x, y, scale); return; }
  const numStalks = 3 + Math.floor(hash2(x, y) * 3);
  if (stage === "growing") {
    for (let i = 0; i < numStalks; i++) {
      const angle = (hash2(x + i, y) - 0.5) * 0.4;
      const stalkH = s * (0.5 + hash2(x, y + i) * 0.3);
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.strokeStyle = "#7CB342";
      ctx.lineWidth = Math.max(1, s * 0.06);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -stalkH);
      ctx.stroke();
      ctx.restore();
    }
    return;
  }
  const isRotten = (stage === "rotten");
  const stalkColor = isRotten ? "#8B7355" : "#D4A940";
  const kernelColor = isRotten ? "#6B5D3F" : "#E6C36A";
  const kernelColor2 = isRotten ? "#5D4E37" : "#D4A940";
  for (let i = 0; i < numStalks; i++) {
    const angle = (hash2(x + i, y) - 0.5) * 0.35;
    const stalkH = s * (0.7 + hash2(x, y + i) * 0.3);
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.strokeStyle = stalkColor;
    ctx.lineWidth = Math.max(1, s * 0.06);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -stalkH);
    ctx.stroke();
    // Kernel head
    setInk(s * 0.06);
    ctx.beginPath();
    ctx.ellipse(0, -stalkH - s * 0.08, s * 0.08, s * 0.14, 0, 0, Math.PI * 2);
    fillAndInk(i % 2 === 0 ? kernelColor : kernelColor2);
    for (let k = 0; k < 3; k++) {
      ctx.beginPath();
      ctx.arc(s * 0.03 * (k % 2 === 0 ? 1 : -1), -stalkH - s * 0.04 + k * s * 0.06, s * 0.035, 0, Math.PI * 2);
      fillAndInk(kernelColor2);
    }
    ctx.restore();
  }
}

function drawTurnip(stage, x, y, scale) {
  const s = scale * 21;
  const jitter = (hash2(x, y) - 0.5) * s * 0.12;
  x += jitter;
  setInk(s * 0.10);
  if (stage === "seed") { drawSprout(x, y, scale); return; }
  if (stage === "growing") {
    ctx.beginPath();
    ctx.arc(x, y - 0.15 * s, 0.35 * s, 0, Math.PI * 2);
    fillAndInk("#66BB6A");
    ctx.beginPath();
    ctx.arc(x, y + 0.1 * s, 0.2 * s, 0, Math.PI * 2);
    fillAndInk("#E8D5B7");
    return;
  }
  if (stage === "rotten") {
    ctx.beginPath();
    ctx.arc(x, y, 0.5 * s, 0, Math.PI * 2);
    fillAndInk("#8B7355");
    return;
  }
  ctx.beginPath();
  ctx.arc(x, y + 0.15 * s, 0.45 * s, 0, Math.PI * 2);
  fillAndInk("#E8D5B7");
  ctx.beginPath();
  ctx.arc(x, y, 0.4 * s, Math.PI, 2 * Math.PI);
  fillAndInk("#9C27B0");
  ctx.beginPath();
  ctx.ellipse(x - 0.15 * s, y - 0.4 * s, 0.1 * s, 0.22 * s, -0.3, 0, Math.PI * 2);
  fillAndInk("#4CAF50");
  ctx.beginPath();
  ctx.ellipse(x + 0.15 * s, y - 0.4 * s, 0.1 * s, 0.22 * s, 0.3, 0, Math.PI * 2);
  fillAndInk("#66BB6A");
}

function drawCrop(cropType, stage, x, y, scale) {
  if (cropType === "cabbage") drawCabbage(stage, x, y, scale);
  else if (cropType === "turnip") drawTurnip(stage, x, y, scale);
  else drawWheat(stage, x, y, scale);
}

// Resource floaters
function addFloater(x, y, text, color) {
  floaters.push({ x, y, text, color, life: 60, maxLife: 60 });
}

function updateFloaters() {
  for (let i = floaters.length - 1; i >= 0; i--) {
    floaters[i].y -= 0.8;
    floaters[i].life--;
    if (floaters[i].life <= 0) floaters.splice(i, 1);
  }
}

function drawFloaters() {
  for (const f of floaters) {
    const alpha = f.life / f.maxLife;
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = f.color;
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 3;
    ctx.strokeText(f.text, f.x, f.y);
    ctx.fillText(f.text, f.x, f.y);
  }
  ctx.globalAlpha = 1;
}

/** Add a message to the game log (auto-removes after 5 seconds) */
function addLogMessage(text) {
  const msg = document.createElement('div');
  msg.className = 'log-msg';
  msg.textContent = text;
  DOM.gameLog.appendChild(msg);
  setTimeout(() => msg.remove(), 5000);
  while (DOM.gameLog.children.length > 5) DOM.gameLog.removeChild(DOM.gameLog.firstChild);
}

function drawSheep(x, y, scale, direction) {
  const s = scale * 24;
  setInk(s * 0.10);
  const facing = -(direction || 1);
  ctx.beginPath();
  ctx.ellipse(x, y, 0.55 * s, 0.40 * s, 0, 0, Math.PI * 2);
  fillAndInk("#F5F5F5");
  ctx.beginPath();
  ctx.ellipse(x - (0.45 * s * facing), y - 0.15 * s, 0.25 * s, 0.22 * s, 0, 0, Math.PI * 2);
  fillAndInk("#E8E8E8");
  ctx.strokeStyle = "rgba(28,20,16,0.8)";
  ctx.lineWidth = Math.max(1, s * 0.08);
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(x - 0.30 * s + i * 0.20 * s, y + 0.30 * s);
    ctx.lineTo(x - 0.30 * s + i * 0.20 * s, y + 0.55 * s);
    ctx.stroke();
  }
  ctx.fillStyle = "rgba(28,20,16,0.9)";
  ctx.beginPath();
  ctx.arc(x - (0.50 * s * facing), y - 0.18 * s, 0.04 * s, 0, Math.PI * 2);
  ctx.fill();
}

// Folk art tree - round canopy on dark trunk
function drawFolkTree(x, y, scale, variation) {
  const s = scale * 28;
  const v = variation || 0;
  setInk(Math.max(1, s * 0.08));
  // Trunk
  const trunkW = s * 0.12;
  const trunkH = s * (0.6 + v * 0.2);
  ctx.beginPath();
  ctx.moveTo(x - trunkW, y);
  ctx.lineTo(x - trunkW * 0.7, y - trunkH);
  ctx.lineTo(x + trunkW * 0.7, y - trunkH);
  ctx.lineTo(x + trunkW, y);
  ctx.closePath();
  fillAndInk("#3D2B1F");
  // Canopy - round blob like folk art
  const canopyColors = ["#2D5016", "#1E6B1E", "#3A7D32", "#2B6B2B"];
  const color = canopyColors[Math.floor(v * canopyColors.length) % canopyColors.length];
  const canopyR = s * (0.45 + v * 0.15);
  const canopyY = y - trunkH - canopyR * 0.6;
  ctx.beginPath();
  ctx.arc(x, canopyY, canopyR, 0, Math.PI * 2);
  fillAndInk(color);
  // Second smaller blob for variety
  if (v > 0.3) {
    const offX = (v - 0.5) * s * 0.3;
    ctx.beginPath();
    ctx.arc(x + offX, canopyY - canopyR * 0.3, canopyR * 0.6, 0, Math.PI * 2);
    fillAndInk(color);
  }
}

// Tree stump for cleared land
function drawStump(x, y, scale) {
  const s = scale * 18;
  setInk(Math.max(1, s * 0.10));
  // Stump body
  ctx.beginPath();
  ctx.moveTo(x - s * 0.2, y);
  ctx.lineTo(x - s * 0.15, y - s * 0.35);
  ctx.lineTo(x + s * 0.15, y - s * 0.35);
  ctx.lineTo(x + s * 0.2, y);
  ctx.closePath();
  fillAndInk("#5D4037");
  // Top of stump
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.35, s * 0.17, s * 0.07, 0, 0, Math.PI * 2);
  fillAndInk("#8D6E63");
}

// Generate tree/stump positions for a hill
const hillFeatures = {};
function generateHillFeatures(hillNum) {
  const config = hillConfigs[hillNum];
  const { start, end } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const hillPath = ALL_HILL_PATHS[hillNum];
  const depth = depthOfHill(config);
  const features = { trees: [], stumps: [] };

  if (config.landType === 'forest') {
    const numTrees = 12 + Math.floor(hash2(hillNum, 42) * 15);
    for (let i = 0; i < numTrees; i++) {
      const tx = start + width * (0.1 + hash2(i * 3, hillNum) * 0.8);
      const ty = GROUND_Y - hillHeight * (0.15 + hash2(i * 3 + 1, hillNum) * 0.7);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (1.0 - heightProgress * 0.35) * lerp(0.55, 1.2, depth);
        features.trees.push({ x: tx, y: ty, scale, variation: hash2(i + 200, hillNum) });
      }
    }
  } else if (config.landType === 'cleared') {
    const numStumps = 5 + Math.floor(hash2(hillNum, 55) * 6);
    for (let i = 0; i < numStumps; i++) {
      const tx = start + width * (0.15 + hash2(i * 7, hillNum + 10) * 0.7);
      const ty = GROUND_Y - hillHeight * (0.15 + hash2(i * 7 + 1, hillNum + 10) * 0.6);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (1.0 - heightProgress * 0.35) * lerp(0.55, 1.2, depth);
        features.stumps.push({ x: tx, y: ty, scale });
      }
    }
    // A few stray trees
    const numTrees = 2 + Math.floor(hash2(hillNum, 77) * 3);
    for (let i = 0; i < numTrees; i++) {
      const tx = start + width * (0.2 + hash2(i * 11, hillNum + 20) * 0.6);
      const ty = GROUND_Y - hillHeight * (0.2 + hash2(i * 11 + 1, hillNum + 20) * 0.5);
      if (hillPath && ctx.isPointInPath(hillPath, tx, ty) && isPointVisible(tx, ty, hillNum)) {
        const heightProgress = clamp01((GROUND_Y - ty) / Math.max(1, hillHeight));
        const scale = (0.8 - heightProgress * 0.3) * lerp(0.55, 1.2, depth);
        features.trees.push({ x: tx, y: ty, scale, variation: hash2(i + 300, hillNum) });
      }
    }
  }

  // Sort by y for depth ordering
  features.trees.sort((a, b) => a.y - b.y);
  features.stumps.sort((a, b) => a.y - b.y);
  return features;
}

function drawForestContent(hillNum, config) {
  if (!hillFeatures[hillNum]) hillFeatures[hillNum] = generateHillFeatures(hillNum);
  const features = hillFeatures[hillNum];
  for (const tree of features.trees) {
    drawFolkTree(tree.x, tree.y, tree.scale, tree.variation);
  }
}

function drawClearedContent(hillNum, config) {
  if (!hillFeatures[hillNum]) hillFeatures[hillNum] = generateHillFeatures(hillNum);
  const features = hillFeatures[hillNum];
  for (const stump of features.stumps) {
    drawStump(stump.x, stump.y, stump.scale);
  }
  for (const tree of features.trees) {
    drawFolkTree(tree.x, tree.y, tree.scale, tree.variation);
  }
}

function drawHouse(house) {
  const { x, y, s, windows, litCount, color, roofColor } = house;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((hash2(x, y) - 0.5) * 0.06);
  setInk(Math.max(1, s * 0.08));
  // Shadow
  ctx.beginPath();
  ctx.ellipse(0, s * 2.0, s * 1.6, s * 0.4, 0, 0, Math.PI * 2);
  fillAndInk("rgba(28,20,16,0.08)");
  // Main body - taller
  ctx.beginPath();
  ctx.rect(-s * 1.4, -s * 0.5, s * 2.8, s * 2.5);
  fillAndInk(color);
  // Steep roof
  ctx.beginPath();
  ctx.moveTo(-s * 1.6, -s * 0.5);
  ctx.lineTo(0, -s * 2.2);
  ctx.lineTo(s * 1.6, -s * 0.5);
  ctx.closePath();
  fillAndInk(roofColor);
  // Chimney
  ctx.beginPath();
  ctx.rect(s * 0.5, -s * 2.4, s * 0.4, s * 1.2);
  fillAndInk("#5D4037");
  ctx.beginPath();
  ctx.rect(s * 0.4, -s * 2.5, s * 0.6, s * 0.15);
  fillAndInk("#4E342E");
  // Door
  ctx.beginPath();
  ctx.rect(-s * 0.3, s * 0.7, s * 0.6, s * 1.3);
  fillAndInk("#5D4037");
  ctx.beginPath();
  ctx.arc(s * 0.2, s * 1.3, s * 0.06, 0, Math.PI * 2);
  fillAndInk("#F1D27E");
  // Windows with cross-panes
  const winW = s * 0.45, winH = s * 0.42;
  const slots = [
    { cx: -s * 0.75, cy: s * 0.15 },
    { cx: s * 0.75, cy: s * 0.15 },
    { cx: -s * 0.75, cy: s * 0.9 },
    { cx: s * 0.75, cy: s * 0.9 }
  ].slice(0, windows);
  for (let i = 0; i < slots.length; i++) {
    const lit = i < litCount;
    const sx = slots[i].cx, sy = slots[i].cy;
    ctx.beginPath();
    ctx.rect(sx - winW/2, sy - winH/2, winW, winH);
    fillAndInk("#EEE8DC");
    ctx.beginPath();
    ctx.rect(sx - winW/2 + s*0.05, sy - winH/2 + s*0.05, winW - s*0.10, winH - s*0.10);
    fillAndInk(lit ? "#F7D97C" : "#42505A");
    // Cross panes
    ctx.strokeStyle = "#EEE8DC";
    ctx.lineWidth = Math.max(1, s * 0.06);
    ctx.beginPath();
    ctx.moveTo(sx, sy - winH/2 + s*0.05);
    ctx.lineTo(sx, sy + winH/2 - s*0.05);
    ctx.moveTo(sx - winW/2 + s*0.05, sy);
    ctx.lineTo(sx + winW/2 - s*0.05, sy);
    ctx.stroke();
  }
  ctx.restore();
}

function drawPeasant(peasant, isShepherd = false, scale = 1) {
  const { x, y, direction } = peasant;
  const s = 32 * scale;
  ctx.save();
  if (direction === -1) {
    ctx.translate(x, y);
    ctx.scale(-1, 1);
    ctx.translate(-x, -y);
  }
  setInk(s * 0.10);
  // Body
  ctx.beginPath();
  ctx.arc(x, y, s * 0.35, 0, Math.PI * 2);
  fillAndInk("#8B6F47");
  // Head
  ctx.beginPath();
  ctx.arc(x, y - s * 0.45, s * 0.25, 0, Math.PI * 2);
  fillAndInk("#D4A574");
  // Hat
  ctx.beginPath();
  ctx.ellipse(x, y - s * 0.65, s * 0.30, s * 0.12, 0, 0, Math.PI * 2);
  fillAndInk("#6B4A2E");
  // Legs
  ctx.strokeStyle = "rgba(28,20,16,0.8)";
  ctx.lineWidth = Math.max(1, s * 0.10);
  ctx.beginPath();
  ctx.moveTo(x - s * 0.15, y + s * 0.30);
  ctx.lineTo(x - s * 0.15, y + s * 0.60);
  ctx.moveTo(x + s * 0.15, y + s * 0.30);
  ctx.lineTo(x + s * 0.15, y + s * 0.60);
  ctx.stroke();
  
  // Shepherd's crook/staff
  if (isShepherd) {
    ctx.strokeStyle = "#5D4037";
    ctx.lineWidth = Math.max(2, s * 0.08);
    ctx.beginPath();
    // Staff shaft
    ctx.moveTo(x + s * 0.35, y + s * 0.5);
    ctx.lineTo(x + s * 0.25, y - s * 0.8);
    // Crook curve at top
    ctx.quadraticCurveTo(x + s * 0.25, y - s * 1.1, x + s * 0.05, y - s * 1.0);
    ctx.stroke();
  }
  
  ctx.restore();
}

function drawMachine(machine, scale = 1) {
  const { x, y, direction } = machine;
  const s = 42 * scale;
  ctx.save();
  if (direction === -1) {
    ctx.translate(x, y);
    ctx.scale(-1, 1);
    ctx.translate(-x, -y);
  }
  setInk(s * 0.07);
  // Wheels (large, on sides)
  ctx.beginPath();
  ctx.arc(x - s * 0.5, y + s * 0.1, s * 0.28, 0, Math.PI * 2);
  fillAndInk("#5D4037");
  ctx.beginPath();
  ctx.arc(x + s * 0.5, y + s * 0.1, s * 0.28, 0, Math.PI * 2);
  fillAndInk("#5D4037");
  // Wheel spokes
  ctx.strokeStyle = "#8D6E63";
  ctx.lineWidth = Math.max(1, s * 0.035);
  for (const wx of [-0.5, 0.5]) {
    for (let a = 0; a < 4; a++) {
      const angle = a * Math.PI / 4;
      ctx.beginPath();
      ctx.moveTo(x + wx * s, y + s * 0.1);
      ctx.lineTo(x + wx * s + Math.cos(angle) * s * 0.22, y + s * 0.1 + Math.sin(angle) * s * 0.22);
      ctx.stroke();
    }
  }
  // Axle bar
  setInk(s * 0.06);
  ctx.beginPath();
  ctx.rect(x - s * 0.55, y - s * 0.05, s * 1.1, s * 0.12);
  fillAndInk("#6D4C41");
  // Seed hopper (trapezoidal box)
  ctx.beginPath();
  ctx.moveTo(x - s * 0.35, y - s * 0.05);
  ctx.lineTo(x - s * 0.28, y - s * 0.45);
  ctx.lineTo(x + s * 0.28, y - s * 0.45);
  ctx.lineTo(x + s * 0.35, y - s * 0.05);
  ctx.closePath();
  fillAndInk("#8B7355");
  // Hopper top rim
  ctx.beginPath();
  ctx.rect(x - s * 0.30, y - s * 0.50, s * 0.60, s * 0.08);
  fillAndInk("#6D4C41");
  // Three coulter tubes
  ctx.strokeStyle = "#555";
  ctx.lineWidth = Math.max(2, s * 0.05);
  for (const offset of [-0.18, 0, 0.18]) {
    ctx.beginPath();
    ctx.moveTo(x + offset * s, y - s * 0.05);
    ctx.lineTo(x + offset * s, y + s * 0.35);
    ctx.stroke();
    // Coulter blade at bottom
    setInk(s * 0.05);
    ctx.beginPath();
    ctx.moveTo(x + offset * s - s * 0.04, y + s * 0.30);
    ctx.lineTo(x + offset * s, y + s * 0.42);
    ctx.lineTo(x + offset * s + s * 0.04, y + s * 0.30);
    ctx.closePath();
    fillAndInk("#78909C");
  }
  // Handle shafts
  ctx.strokeStyle = "#5D4037";
  ctx.lineWidth = Math.max(2, s * 0.06);
  ctx.beginPath();
  ctx.moveTo(x - s * 0.35, y - s * 0.35);
  ctx.lineTo(x - s * 0.55, y - s * 0.75);
  ctx.moveTo(x + s * 0.35, y - s * 0.35);
  ctx.lineTo(x + s * 0.55, y - s * 0.75);
  ctx.stroke();
  ctx.restore();
}

// House creation
function createHouse(hillNum, config) {
  const houses = game.houses[hillNum] || [];
  if (houses.length >= 5) return null;
  const anchor = getHillTopAnchor(hillNum, config);
  const depth = depthOfHill(config);
  const spread = (config.end - config.start) * 0.6;
  const offsetX = (houses.length - 2) * (spread / 5);
  const s = 20 + depth * 5;
  // Calculate hill surface y at house x position
  const houseX = anchor.x + offsetX;
  const { start, end } = config;
  const width = end - start;
  const mid = (start + end) / 2;
  const hillTop = getHillTop(config);
  const t = clamp01(Math.abs(houseX - mid) / (width / 2));
  const surfaceY = hillTop + (GROUND_Y - hillTop) * Math.pow(t, 1.5);
  const bodyColors = ["#C0392B", "#FDFEFE", "#F5E6CA", "#C62828", "#ECEFF1"];
  const roofColors = ["#2B2B2E", "#3A2F2A", "#1F2A44", "#795548"];
  return {
    hillNum, x: houseX, y: surfaceY - s * 2.0, s,
    windows: 3 + Math.floor(Math.random() * 2),
    litCount: 0,
    color: bodyColors[Math.floor(Math.random() * bodyColors.length)],
    roofColor: roofColors[Math.floor(Math.random() * roofColors.length)]
  };
}

// Peasant creation
function createPeasant(houseHillNum, houseIdx) {
  const houses = game.houses[houseHillNum];
  if (!houses || !houses[houseIdx]) return null;
  const house = houses[houseIdx];
  return {
    id: Date.now() + Math.random(),
    homeHill: houseHillNum,
    houseIdx,
    x: house.x, y: house.y,
    targetX: house.x, targetY: house.y,
    task: TASKS.IDLE,
    taskData: {},
    speed: 0.8 + Math.random() * 0.4,
    idleTimer: 60,
    direction: 1,
    workHill: null,
    isShepherd: false
  };
}

function createMachine(hillNum) {
  const config = hillConfigs[hillNum];
  const anchor = getHillTopAnchor(hillNum, config);
  return {
    id: Date.now() + Math.random(),
    homeHill: hillNum,
    x: anchor.x, y: anchor.y + 20,
    targetX: anchor.x, targetY: anchor.y + 20,
    task: TASKS.IDLE,
    taskData: {},
    speed: 2.0,
    idleTimer: 30,
    direction: 1,
    workHill: null
  };
}

/**
 * Updates peasant count based on house capacity.
 * Adds peasants to fill houses, removes excess peasants if houses demolished.
 */
function updatePeasantCount() {
  let totalCapacity = 0;
  for (const hillNum in game.houses) {
    totalCapacity += game.houses[hillNum].length * GC.PEASANTS_PER_HOUSE;
  }

  // Add peasants to fill capacity
  while (game.peasants.length < totalCapacity) {
    for (const hillNum in game.houses) {
      const houses = game.houses[hillNum];
      for (let hIdx = 0; hIdx < houses.length; hIdx++) {
        if (game.peasants.length >= totalCapacity) break;
        const peasant = createPeasant(Number(hillNum), hIdx);
        if (peasant) game.peasants.push(peasant);
      }
    }
  }

  // Remove excess peasants
  if (game.peasants.length > totalCapacity) {
    game.peasants = game.peasants.slice(0, totalCapacity);
  }

  // Build occupancy map in a single pass (performance optimization)
  const occupancy = {};
  for (const p of game.peasants) {
    const key = `${p.homeHill}_${p.houseIdx}`;
    occupancy[key] = (occupancy[key] || 0) + 1;
  }

  // Update lit window counts
  for (const hillNum in game.houses) {
    const houses = game.houses[hillNum];
    for (let hIdx = 0; hIdx < houses.length; hIdx++) {
      const count = occupancy[`${hillNum}_${hIdx}`] || 0;
      houses[hIdx].litCount = Math.min(houses[hIdx].windows, Math.ceil(count / 1.5));
    }
  }

  updateUI();
}

// Generate visible nodes for a row at fixed pixel intervals
function generateRowNodes(hillNum, rowIdx) {
  const config = hillConfigs[hillNum];
  const { start, end } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const spacingMult = lerp(0.65, 1.45, depth);
  const effectiveNumLines = Math.round(clamp01(lerp(0.95, 1.10, 1 - depth)) * getNumRows(config));
  const effectiveSpacing = SETTINGS.lineSpacing * spacingMult;
  const slope = (hillNum % 2 === 0) ? 1 : -1;
  const offset = (rowIdx - effectiveNumLines / 2) * effectiveSpacing;
  
  const hillPath = ALL_HILL_PATHS[hillNum];
  if (!hillPath) return [];
  
  // Sample many points along the line
  const allPoints = [];
  for (let seg = 0; seg <= 100; seg++) {
    const t = seg / 100;
    const x = start + width * t;
    const centerX = start + width / 2;
    const centerY = hillTop + hillHeight / 2;
    let y = slope * (x - centerX) + centerY + offset;
    if (SETTINGS.curveAmount > 0) {
      const distFromCenter = 1 - Math.abs(t - 0.5) * 2;
      y += distFromCenter * distFromCenter * SETTINGS.curveAmount * lerp(0.9, 1.15, depth);
    }
    allPoints.push({ x, y });
  }
  
  // Now pick nodes at fixed pixel intervals, only if visible
  const nodes = [];
  let distAccum = 0;
  let lastPoint = allPoints[0];
  
  for (let i = 1; i < allPoints.length; i++) {
    const p = allPoints[i];
    const dx = p.x - lastPoint.x;
    const dy = p.y - lastPoint.y;
    const segDist = Math.sqrt(dx * dx + dy * dy);
    distAccum += segDist;
    
    if (distAccum >= GC.NODE_SPACING_PX) {
      // Check if this point is within the hill and visible (not occluded)
      if (ctx.isPointInPath(hillPath, p.x, p.y) && isPointVisible(p.x, p.y, hillNum)) {
        nodes.push({ x: p.x, y: p.y, hasCrop: false, crop: null });
      }
      distAccum = 0;
    }
    lastPoint = p;
  }
  
  return nodes;
}

// Initialize or get row nodes
function getRowNodes(hillNum, rowIdx) {
  const config = hillConfigs[hillNum];
  if (!config.rowNodes) config.rowNodes = {};
  if (!config.rowNodes[rowIdx]) {
    config.rowNodes[rowIdx] = generateRowNodes(hillNum, rowIdx);
  }
  return config.rowNodes[rowIdx];
}

function findWorkForPeasant(peasant) {
  const tasks = [];
  const desperate = game.peasants.length < 6;
  for (const key of VISIBLE_HILLS) {
    const config = hillConfigs[key];
    if (!config) continue;
    if (config.landType === 'farm' && config.rowOwnership && !config.isFallow && !config.enclosed) {
      for (let rowIdx = 0; rowIdx < config.rowOwnership.length; rowIdx++) {
        const nodes = getRowNodes(key, rowIdx);
        const emptyNodes = nodes.filter(n => !n.hasCrop);
        const readyNodes = nodes.filter(n => n.crop && n.crop.stage === 'ready');

        if (emptyNodes.length > 0) {
          tasks.push({ type: TASKS.PLANTING, hillNum: key, rowIdx, weight: desperate ? 1 : 3 });
        }
        if (readyNodes.length > 0) {
          tasks.push({ type: TASKS.HARVESTING, hillNum: key, rowIdx, weight: desperate ? 50 : 12 });
        }
      }
    } else if (config.landType === 'commons') {
      tasks.push({ type: TASKS.TENDING_COMMONS, hillNum: key, weight: desperate ? 10 : 3 });
    }
  }

  if (tasks.length === 0) { goHome(peasant); return; }

  const totalWeight = tasks.reduce((sum, t) => sum + t.weight, 0);
  let rand = Math.random() * totalWeight;
  let chosen = tasks[0];
  for (const task of tasks) {
    rand -= task.weight;
    if (rand <= 0) { chosen = task; break; }
  }
  
  peasant.task = TASKS.WALKING_TO_FIELD;
  peasant.workHill = chosen.hillNum;
  peasant.isShepherd = (chosen.type === TASKS.TENDING_COMMONS);
  
  if (chosen.rowIdx !== undefined) {
    const nodes = getRowNodes(chosen.hillNum, chosen.rowIdx);
    let targetNodes;
    if (chosen.type === TASKS.PLANTING) {
      targetNodes = nodes.filter(n => !n.hasCrop);
    } else {
      targetNodes = nodes.filter(n => n.crop && n.crop.stage === 'ready');
    }
    
    if (targetNodes.length === 0) { findWorkForPeasant(peasant); return; }
    
    peasant.taskData = {
      hillNum: chosen.hillNum,
      rowIdx: chosen.rowIdx,
      taskType: chosen.type,
      nodeIndex: 0,
      nodes: targetNodes
    };
    
    peasant.targetX = targetNodes[0].x;
    peasant.targetY = targetNodes[0].y;
  } else {
    // Commons - find a visible spot
    const config = hillConfigs[chosen.hillNum];
    const hillPath = ALL_HILL_PATHS[chosen.hillNum];
    let targetX, targetY;
    let attempts = 0;
    do {
      targetX = config.start + (config.end - config.start) * (0.2 + Math.random() * 0.6);
      targetY = GROUND_Y - (GROUND_Y - getHillTop(config)) * (0.3 + Math.random() * 0.4);
      attempts++;
    } while (attempts < 20 && (!ctx.isPointInPath(hillPath, targetX, targetY) || !isPointVisible(targetX, targetY, chosen.hillNum)));
    
    peasant.taskData = { hillNum: chosen.hillNum, taskType: chosen.type };
    peasant.targetX = targetX;
    peasant.targetY = targetY;
  }
}

function goHome(peasant) {
  peasant.task = TASKS.WALKING_HOME;
  peasant.workHill = null;
  peasant.isShepherd = false;
  const houses = game.houses[peasant.homeHill];
  if (houses && houses[peasant.houseIdx]) {
    peasant.targetX = houses[peasant.houseIdx].x;
    peasant.targetY = houses[peasant.houseIdx].y;
  }
  peasant.taskData = {};
}

/** Update peasant movement each tick */
function updatePeasantMovement() {
  for (const p of game.peasants) {
    const dx = p.targetX - p.x;
    const dy = p.targetY - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (Math.abs(dx) > 1) p.direction = dx > 0 ? 1 : -1;

    if (dist < GC.ARRIVAL_THRESHOLD) {
      handlePeasantArrival(p);
    } else {
      let moveX = (dx / dist) * p.speed;
      let moveY = (dy / dist) * p.speed;

      // Avoid enclosed hills with improved pathfinding
      for (const key in hillConfigs) {
        const eConfig = hillConfigs[key];
        if (!eConfig.enclosed) continue;
        const eNum = Number(key);
        if (eNum === p.workHill || eNum === p.homeHill) continue;
        const ePath = ALL_HILL_PATHS[key];
        if (ePath && ctx.isPointInPath(ePath, p.x + moveX, p.y + moveY)) {
          const hillMidX = (eConfig.start + eConfig.end) / 2;
          const hillTop = getHillTop(eConfig);
          const hillMidY = (hillTop + GROUND_Y) / 2;
          const goRight = p.targetX > p.x;
          moveX = (goRight ? 1 : -1) * p.speed;
          const goUp = p.y > hillMidY;
          const jitter = (Math.random() - 0.5) * 0.3;
          moveY = ((goUp ? -1 : 1) * 0.5 + jitter) * p.speed;
          break;
        }
      }

      p.x += moveX;
      p.y += moveY;
    }
  }
}

/** Check and restore fallow fields that have completed their rest period */
function updateFallowFields() {
  for (const fk in hillConfigs) {
    const fc = hillConfigs[fk];
    if (fc.landType === 'farm' && fc.isFallow && fc.fallowStartDay !== null) {
      if (game.day - fc.fallowStartDay >= GC.FALLOW_DAYS) {
        fc.soilHealth = 100;
        fc.isFallow = false;
        fc.fallowStartDay = null;
        fc.color = '#6B5D3F';
        addLogMessage('Fallow field restored \u2014 soil health 100%');
      }
    }
  }
}

/** Handle food consumption and peasant starvation */
function consumeFood() {
  const foodNeeded = game.peasants.length * GC.FOOD_PER_PEASANT;

  // Check if we have enough food BEFORE subtracting
  if (game.food < foodNeeded) {
    const deficit = foodNeeded - game.food;
    game.food = 0;

    // Calculate how many peasants must leave
    let houseCapacity = 0;
    for (const hn in game.houses) houseCapacity += game.houses[hn].length * GC.PEASANTS_PER_HOUSE;
    const minPeasants = houseCapacity > 0 ? Math.min(2, houseCapacity) : 0;
    const toRemove = Math.min(game.peasants.length - minPeasants, Math.ceil(deficit / GC.FOOD_PER_PEASANT));

    for (let i = 0; i < toRemove && game.peasants.length > minPeasants; i++) {
      game.peasants.pop();
      addLogMessage('A peasant has moved away \u2014 not enough food');
    }
  } else {
    game.food -= foodNeeded;
  }
}

/** Handle peasant repopulation - up to MAX_PEASANTS_PER_DAY can move in */
function repopulatePeasants() {
  if (game.food <= 0) return;

  let houseCapacity = 0;
  for (const hn in game.houses) houseCapacity += game.houses[hn].length * GC.PEASANTS_PER_HOUSE;
  if (game.peasants.length >= houseCapacity) return;

  // Build occupancy map for efficient lookup
  const occupancy = {};
  for (const p of game.peasants) {
    const key = `${p.homeHill}_${p.houseIdx}`;
    occupancy[key] = (occupancy[key] || 0) + 1;
  }

  // Add up to MAX_PEASANTS_PER_DAY peasants
  let added = 0;
  for (const hn in game.houses) {
    if (added >= GC.MAX_PEASANTS_PER_DAY) break;
    const houses = game.houses[hn];
    for (let hIdx = 0; hIdx < houses.length; hIdx++) {
      if (added >= GC.MAX_PEASANTS_PER_DAY) break;
      const count = occupancy[`${hn}_${hIdx}`] || 0;
      if (count < GC.PEASANTS_PER_HOUSE) {
        const peasant = createPeasant(Number(hn), hIdx);
        if (peasant) {
          game.peasants.push(peasant);
          occupancy[`${hn}_${hIdx}`] = count + 1;
          addLogMessage('A peasant has moved into a vacant cottage');
          added++;
        }
      }
    }
  }

  // Update lit windows using occupancy map
  for (const hn in game.houses) {
    const houses = game.houses[hn];
    for (let hIdx = 0; hIdx < houses.length; hIdx++) {
      const count = occupancy[`${hn}_${hIdx}`] || 0;
      houses[hIdx].litCount = Math.min(houses[hIdx].windows, Math.ceil(count / 1.5));
    }
  }
}

/** Advance day and trigger day-end events */
function advanceDay() {
  game.day++;
  if (game.day === 40 && !game.turnipsUnlocked) showNewspaper();
  if (game.day === 80 && !game.mechanicsUnlocked) showMechanicsNewspaper();
  if (game.day === 120 && !game.enclosureUnlocked) showEnclosureNewspaper();

  updateFallowFields();
  consumeFood();
  repopulatePeasants();
  updateUI();
}

/** Main peasant update - movement and day cycle */
function updatePeasants() {
  updatePeasantMovement();

  game.dayTimer++;
  if (game.dayTimer >= game.dayLength) {
    game.dayTimer = 0;
    advanceDay();
  }
}

/** Handle peasant arrival at target location */
function handlePeasantArrival(p) {
  switch (p.task) {
    case TASKS.WALKING_TO_FIELD:
      p.task = p.taskData.taskType;
      if (p.task === TASKS.TENDING_COMMONS) {
        p.idleTimer = GC.COMMONS_WORK_TIME;
      } else if (!p.taskData.nodes) {
        p.idleTimer = GC.COMMONS_WORK_TIME + Math.random() * (GC.PEASANT_IDLE_MAX - GC.COMMONS_WORK_TIME);
      }
      break;
      
    case TASKS.PLANTING:
      if (p.taskData.nodes) {
        const node = p.taskData.nodes[p.taskData.nodeIndex];
        // Plant immediately at this node
        if (node && !node.hasCrop) {
          node.hasCrop = true;
          node.crop = { stage: 'seed', growthTimer: 0 };
        }
        
        // Move to next node
        p.taskData.nodeIndex++;
        if (p.taskData.nodeIndex >= p.taskData.nodes.length) {
          findWorkForPeasant(p);
        } else {
          const nextNode = p.taskData.nodes[p.taskData.nodeIndex];
          p.targetX = nextNode.x;
          p.targetY = nextNode.y;
        }
      }
      break;
      
    case TASKS.HARVESTING:
      if (p.taskData.nodes) {
        const node = p.taskData.nodes[p.taskData.nodeIndex];
        // Harvest immediately at this node
        if (node && node.crop && node.crop.stage === 'ready') {
          const config = hillConfigs[p.taskData.hillNum];
          const rowOwner = config.rowOwnership[p.taskData.rowIdx];
          const yieldBonus = getYieldBonus();
          if (rowOwner === 'player') {
            game.money += yieldBonus;
            addFloater(node.x, node.y, '+¬£' + yieldBonus, '#2E7D32');
          } else {
            game.food += yieldBonus * 2;
            addFloater(node.x, node.y, '+' + (yieldBonus * 2) + ' food', '#E65100');
          }
          config.soilHealth = Math.max(0, (config.soilHealth || 100) - 1);
          node.hasCrop = false;
          node.crop = null;
          updateUI();
        }
        
        // Move to next node
        p.taskData.nodeIndex++;
        if (p.taskData.nodeIndex >= p.taskData.nodes.length) {
          findWorkForPeasant(p);
        } else {
          const nextNode = p.taskData.nodes[p.taskData.nodeIndex];
          p.targetX = nextNode.x;
          p.targetY = nextNode.y;
        }
      }
      break;
      
    case TASKS.TENDING_COMMONS:
      p.idleTimer--;
      if (p.idleTimer <= 0) {
        game.food += GC.COMMONS_FOOD_YIELD;
        addFloater(p.x, p.y, '+' + GC.COMMONS_FOOD_YIELD + ' food', '#E65100');
        updateUI();
        findWorkForPeasant(p);
      }
      break;

    case TASKS.WALKING_HOME:
      p.task = TASKS.IDLE;
      p.idleTimer = GC.PEASANT_IDLE_MIN + Math.random() * (GC.PEASANT_IDLE_MAX - GC.PEASANT_IDLE_MIN);
      break;
      
    case TASKS.IDLE:
      p.idleTimer--;
      if (p.idleTimer <= 0) findWorkForPeasant(p);
      break;
  }
}

// Machine AI
function findWorkForMachine(machine) {
  const farmTasks = [];
  for (const key of VISIBLE_HILLS) {
    const config = hillConfigs[key];
    if (!config || config.landType !== 'farm' || !config.rowOwnership || config.isFallow) continue;

    // Collect nodes from 3 adjacent rows grouped by column (X position)
    // Use half the node spacing as bucket size to group nodes that are visually aligned
    const columnBucketSize = GC.NODE_SPACING_PX / 2;
    const plantColumns = {};
    const harvestColumns = {};
    let plantRowCount = 0;
    let harvestRowCount = 0;

    for (let rowIdx = 0; rowIdx < config.rowOwnership.length; rowIdx++) {
      const nodes = getRowNodes(key, rowIdx);
      const empty = nodes.filter(n => !n.hasCrop);
      const ready = nodes.filter(n => n.crop && n.crop.stage === 'ready');

      if (empty.length > 0 && plantRowCount < 3) {
        for (const n of empty) {
          const colKey = Math.floor(n.x / columnBucketSize);
          if (!plantColumns[colKey]) plantColumns[colKey] = { x: n.x, y: n.y, nodes: [] };
          plantColumns[colKey].nodes.push({ node: n, rowIdx });
        }
        plantRowCount++;
      }
      if (ready.length > 0 && harvestRowCount < 3) {
        for (const n of ready) {
          const colKey = Math.floor(n.x / columnBucketSize);
          if (!harvestColumns[colKey]) harvestColumns[colKey] = { x: n.x, y: n.y, nodes: [] };
          harvestColumns[colKey].nodes.push({ node: n, rowIdx });
        }
        harvestRowCount++;
      }
    }

    // Convert columns to sorted arrays (by X position)
    const plantTargets = Object.values(plantColumns).sort((a, b) => a.x - b.x);
    const harvestTargets = Object.values(harvestColumns).sort((a, b) => a.x - b.x);

    if (harvestTargets.length > 0) farmTasks.push({ type: TASKS.HARVESTING, hillNum: key, columns: harvestTargets, weight: 12 });
    if (plantTargets.length > 0) farmTasks.push({ type: TASKS.PLANTING, hillNum: key, columns: plantTargets, weight: 3 });
  }

  if (farmTasks.length === 0) { goMachineHome(machine); return; }

  const totalWeight = farmTasks.reduce((sum, t) => sum + t.weight, 0);
  let rand = Math.random() * totalWeight;
  let chosen = farmTasks[0];
  for (const task of farmTasks) {
    rand -= task.weight;
    if (rand <= 0) { chosen = task; break; }
  }

  machine.task = TASKS.WALKING_TO_FIELD;
  machine.workHill = chosen.hillNum;
  machine.taskData = {
    hillNum: chosen.hillNum,
    taskType: chosen.type,
    columnIndex: 0,
    columns: chosen.columns
  };
  machine.targetX = chosen.columns[0].x;
  machine.targetY = chosen.columns[0].y;
}

function goMachineHome(machine) {
  machine.task = TASKS.WALKING_HOME;
  machine.workHill = null;
  const config = hillConfigs[machine.homeHill];
  if (config) {
    const anchor = getHillTopAnchor(machine.homeHill, config);
    machine.targetX = anchor.x;
    machine.targetY = anchor.y + 20;
  }
  machine.taskData = {};
}

function handleMachineArrival(m) {
  switch (m.task) {
    case TASKS.WALKING_TO_FIELD:
      m.task = m.taskData.taskType;
      break;

    case TASKS.PLANTING:
      if (m.taskData.columns) {
        const column = m.taskData.columns[m.taskData.columnIndex];
        if (column) {
          // Plant all nodes in this column (up to 3 rows) at once
          for (const target of column.nodes) {
            if (!target.node.hasCrop) {
              target.node.hasCrop = true;
              target.node.crop = { stage: 'seed', growthTimer: 0 };
            }
          }
        }
        m.taskData.columnIndex++;
        if (m.taskData.columnIndex >= m.taskData.columns.length) {
          findWorkForMachine(m);
        } else {
          const next = m.taskData.columns[m.taskData.columnIndex];
          m.targetX = next.x;
          m.targetY = next.y;
        }
      }
      break;

    case TASKS.HARVESTING:
      if (m.taskData.columns) {
        const column = m.taskData.columns[m.taskData.columnIndex];
        if (column) {
          const config = hillConfigs[m.taskData.hillNum];
          const yieldBonus = getYieldBonus();
          // Harvest all nodes in this column (up to 3 rows) at once
          for (const target of column.nodes) {
            if (target.node.crop && target.node.crop.stage === 'ready') {
              const rowOwner = config.rowOwnership[target.rowIdx];
              if (rowOwner === 'player') {
                game.money += yieldBonus;
                addFloater(target.node.x, target.node.y, '+¬£' + yieldBonus, '#2E7D32');
              } else {
                game.food += yieldBonus * 2;
                addFloater(target.node.x, target.node.y, '+' + (yieldBonus * 2) + ' food', '#E65100');
              }
              config.soilHealth = Math.max(0, (config.soilHealth || 100) - 1);
              target.node.hasCrop = false;
              target.node.crop = null;
            }
          }
          updateUI();
        }
        m.taskData.columnIndex++;
        if (m.taskData.columnIndex >= m.taskData.columns.length) {
          findWorkForMachine(m);
        } else {
          const next = m.taskData.columns[m.taskData.columnIndex];
          m.targetX = next.x;
          m.targetY = next.y;
        }
      }
      break;

    case TASKS.WALKING_HOME:
      m.task = TASKS.IDLE;
      m.idleTimer = GC.MACHINE_IDLE_MIN + Math.random() * (GC.MACHINE_IDLE_MAX - GC.MACHINE_IDLE_MIN);
      break;

    case TASKS.IDLE:
      m.idleTimer--;
      if (m.idleTimer <= 0) findWorkForMachine(m);
      break;
  }
}

/** Update machine movement each tick */
function updateMachines() {
  for (const m of game.machines) {
    const dx = m.targetX - m.x;
    const dy = m.targetY - m.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (Math.abs(dx) > 1) m.direction = dx > 0 ? 1 : -1;

    if (dist < GC.ARRIVAL_THRESHOLD) {
      handleMachineArrival(m);
    } else {
      m.x += (dx / dist) * m.speed;
      m.y += (dy / dist) * m.speed;
    }
  }
}

// Sheep
function initializeSheep(hillNum, config) {
  const { start, end } = config;
  const width = end - start;
  const numSheep = 8 + Math.floor(hash2(hillNum, 999) * 8);
  const sheep = [];
  for (let i = 0; i < numSheep; i++) {
    sheep.push({
      x: start + width * (0.2 + hash2(i, hillNum) * 0.6),
      yProgress: 0.3 + hash2(i + 100, hillNum) * 0.4,
      speed: 0.3 + hash2(i + 500, hillNum) * 0.4,
      direction: hash2(i + 1000, hillNum) > 0.5 ? 1 : -1,
      bounds: { start: start + 100, end: end - 100 }
    });
  }
  return sheep;
}

function updateSheep(sheep) {
  for (const s of sheep) {
    s.x += s.direction * s.speed;
    if (s.x < s.bounds.start || s.x > s.bounds.end) s.direction *= -1;
  }
}

/**
 * Updates crop growth and rot for all farms.
 * Growth time increases with lower soil health.
 * Rot time decreases with lower soil health.
 */
function updateCropGrowth() {
  for (const key of VISIBLE_HILLS) {
    const config = hillConfigs[key];
    if (!config || config.landType !== 'farm' || !config.rowNodes) continue;
    if (config.isFallow) continue;
    const healthPct = (config.soilHealth !== undefined ? config.soilHealth : 100) / 100;
    const effectiveGrowthTime = Math.round(GC.CROP_GROWTH_TIME * (1 + (1 - healthPct) * 2));
    const effectiveRotTime = Math.round(GC.CROP_ROT_TIME * Math.max(0.2, healthPct));
    for (const rowIdx in config.rowNodes) {
      for (const node of config.rowNodes[rowIdx]) {
        if (!node.crop) continue;
        if (node.crop.stage === 'rotten') {
          node.crop.rotTimer = (node.crop.rotTimer || 0) + 1;
          if (node.crop.rotTimer >= GC.ROTTEN_REMOVAL_TIME) {
            node.hasCrop = false;
            node.crop = null;
          }
          continue;
        }
        if (node.crop.stage === 'ready') {
          node.crop.rotTimer = (node.crop.rotTimer || 0) + 1;
          if (node.crop.rotTimer >= effectiveRotTime) {
            node.crop.stage = 'rotten';
            node.crop.rotTimer = 0;
          }
          continue;
        }
        node.crop.growthTimer++;
        if (node.crop.growthTimer >= effectiveGrowthTime) {
          node.crop.growthTimer = 0;
          const stageIdx = CROP_STAGES.indexOf(node.crop.stage);
          if (stageIdx < CROP_STAGES.length - 1) {
            node.crop.stage = CROP_STAGES[stageIdx + 1];
          }
        }
      }
    }
  }
}

// Farm initialization
function initializeFarmHill(config) {
  const effectiveNumLines = getNumRows(config);
  config.rowOwnership = [];
  config.rowNodes = null;
  if (config.soilHealth === undefined) config.soilHealth = 100;
  if (!config.isFallow) config.isFallow = false;
  if (!config.fallowStartDay) config.fallowStartDay = null;
  for (let i = 0; i < effectiveNumLines; i++) {
    config.rowOwnership.push(Math.random() < 0.33 ? "peasant" : "player");
  }
}

/** Draw farm content including rows, crops, and soil health overlay */
function drawFarmContent(hillNum, config) {
  if (!config.rowOwnership) return;

  const { start, end, cropType } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const spacingMult = lerp(0.65, 1.45, depth);
  const cropSizeMult = lerp(0.70, 1.35, depth);
  const effectiveNumLines = Math.round(clamp01(lerp(0.95, 1.10, 1 - depth)) * getNumRows(config));
  const effectiveSpacing = SETTINGS.lineSpacing * spacingMult;
  const slope = (hillNum % 2 === 0) ? 1 : -1;
  const hillPath = ALL_HILL_PATHS[hillNum];

  // Visual feedback for low soil health - overlay a warning tint
  const health = config.soilHealth !== undefined ? config.soilHealth : 100;
  if (health < 60 && !config.isFallow) {
    ctx.save();
    ctx.clip(hillPath);
    // Red/brown tint that intensifies as health drops
    const severity = 1 - (health / 60);
    ctx.fillStyle = `rgba(139, 69, 19, ${severity * 0.25})`;
    ctx.fillRect(start, hillTop, width, hillHeight);
    ctx.restore();
  }

  // Draw row lines
  for (let lineIdx = 0; lineIdx < effectiveNumLines; lineIdx++) {
    const offset = (lineIdx - effectiveNumLines / 2) * effectiveSpacing;
    const owner = config.rowOwnership[lineIdx] || "player";

    ctx.save();
    ctx.clip(hillPath);
    // Fade row lines when soil is unhealthy
    const healthAlpha = lerp(0.3, 1, health / 100);
    ctx.strokeStyle = owner === "player"
      ? `rgba(28,20,16,${0.70 * healthAlpha})`
      : `rgba(139,111,78,${0.60 * healthAlpha})`;
    ctx.lineWidth = lerp(1.2, 2.2, depth);
    ctx.beginPath();
    
    for (let seg = 0; seg <= 60; seg++) {
      const t = seg / 60;
      const x = start + width * t;
      const centerX = start + width / 2;
      const centerY = hillTop + hillHeight / 2;
      let y = slope * (x - centerX) + centerY + offset;
      if (SETTINGS.curveAmount > 0) {
        const distFromCenter = 1 - Math.abs(t - 0.5) * 2;
        y += distFromCenter * distFromCenter * SETTINGS.curveAmount * lerp(0.9, 1.15, depth);
      }
      if (seg === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
    
    // Draw crops at nodes
    const nodes = getRowNodes(hillNum, lineIdx);
    for (const node of nodes) {
      if (node.crop) {
        const heightProgress = clamp01((GROUND_Y - node.y) / Math.max(1, hillHeight));
        const scale = (1.05 - heightProgress * 0.35) * cropSizeMult;
        drawCrop(cropType || 'wheat', node.crop.stage, node.x, node.y, scale);
      }
    }
  }
}

function drawFence(hillNum, config) {
  const { start, end } = config;
  const width = end - start;
  const hillTop = getHillTop(config);
  const depth = depthOfHill(config);
  const scaleMult = lerp(0.7, 1.3, depth);
  const mid = (start + end) / 2;
  const hillPath = ALL_HILL_PATHS[hillNum];
  const postSpacing = 35 * scaleMult;
  const postH = 14 * scaleMult;
  const postW = Math.max(1, 2.5 * scaleMult);

  // Bottom fence posts
  const bottomPosts = [];
  for (let x = start + width * 0.08; x <= end - width * 0.08; x += postSpacing) {
    const t = clamp01(Math.abs(x - mid) / (width / 2));
    const surfaceY = hillTop + (GROUND_Y - hillTop) * Math.pow(t, 1.5);
    const fenceY = surfaceY + (GROUND_Y - surfaceY) * 0.7;
    if (fenceY < GROUND_Y - 5 && hillPath && ctx.isPointInPath(hillPath, x, fenceY)) {
      bottomPosts.push({ x, y: fenceY });
    }
  }

  // Top fence posts (along the hill crest)
  const topPosts = [];
  for (let x = start + width * 0.15; x <= end - width * 0.15; x += postSpacing) {
    const t = clamp01(Math.abs(x - mid) / (width / 2));
    const surfaceY = hillTop + (GROUND_Y - hillTop) * Math.pow(t, 1.5);
    const fenceY = surfaceY + (GROUND_Y - surfaceY) * 0.15;
    if (fenceY < GROUND_Y - 5 && hillPath && ctx.isPointInPath(hillPath, x, fenceY)) {
      topPosts.push({ x, y: fenceY });
    }
  }

  // Helper to draw a fence row
  function drawFenceRow(posts) {
    if (posts.length < 2) return;

    // Horizontal rails
    ctx.strokeStyle = "#8B7355";
    ctx.lineWidth = Math.max(1, 1.5 * scaleMult);
    for (const railPct of [0.35, 0.7]) {
      ctx.beginPath();
      for (let i = 0; i < posts.length; i++) {
        const px = posts[i].x, py = posts[i].y - postH * railPct;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    // Posts
    setInk(Math.max(1, postW * 0.5));
    for (const p of posts) {
      ctx.beginPath();
      ctx.rect(p.x - postW / 2, p.y - postH, postW, postH);
      fillAndInk("#5D4037");
    }
  }

  drawFenceRow(topPosts);
  drawFenceRow(bottomPosts);
}

function drawCommonsContent(hillNum, config) {
  const hillPath = ALL_HILL_PATHS[hillNum];
  const hillTop = getHillTop(config);
  const hillHeight = GROUND_Y - hillTop;
  const depth = depthOfHill(config);
  const sheep = sheepState[hillNum] || [];
  
  for (const s of sheep) {
    const y = GROUND_Y - hillHeight * s.yProgress;
    if (!ctx.isPointInPath(hillPath, s.x, y)) continue;
    if (!isPointVisible(s.x, y, hillNum)) continue;
    const heightProgress = clamp01((GROUND_Y - y) / Math.max(1, hillHeight));
    const scale = (1.05 - heightProgress * 0.35) * lerp(0.70, 1.35, depth);
    drawSheep(s.x, y, scale, s.direction);
  }
}

/** Main render function - draws all game elements each frame */
function render() {
  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  const skyGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
  skyGradient.addColorStop(0, "#87CEEB");
  skyGradient.addColorStop(1, "#B0E0E6");
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  // Use pre-sorted hill keys (cached at init)
  for (const i of sortedHillKeys) {
    const config = hillConfigs[i];
    ctx.fillStyle = config.color;
    const path = ALL_HILL_PATHS[i];
    ctx.fill(path);
    ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
    ctx.lineWidth = 2;
    ctx.stroke(path);

    // Only draw content on visible hills
    if (VISIBLE_HILLS.includes(i)) {
      switch (config.landType) {
        case "farm": drawFarmContent(i, config); if (config.enclosed) drawFence(i, config); break;
        case "commons": drawCommonsContent(i, config); break;
        case "forest": drawForestContent(i, config); break;
        case "cleared": drawClearedContent(i, config); break;
      }
      if (game.houses[i]) {
        for (const house of game.houses[i]) drawHouse(house);
      }
    }
  }

  // Draw peasants (scaled by hill depth)
  for (const peasant of game.peasants) {
    const pHillNum = peasant.workHill || peasant.homeHill;
    if (isPointVisible(peasant.x, peasant.y, pHillNum)) {
      const pConfig = hillConfigs[pHillNum];
      if (pConfig) {
        const pDepth = depthOfHill(pConfig);
        const pHillHeight = GROUND_Y - getHillTop(pConfig);
        const pHP = clamp01((GROUND_Y - peasant.y) / Math.max(1, pHillHeight));
        const pScale = (1.05 - pHP * 0.35) * lerp(0.70, 1.35, pDepth);
        drawPeasant(peasant, peasant.isShepherd, pScale);
      } else {
        drawPeasant(peasant, peasant.isShepherd);
      }
    }
  }

  // Draw machines
  for (const machine of game.machines) {
    const mHillNum = machine.workHill || machine.homeHill;
    if (isPointVisible(machine.x, machine.y, mHillNum)) {
      const mConfig = hillConfigs[mHillNum];
      if (mConfig) {
        const mDepth = depthOfHill(mConfig);
        const mHillHeight = GROUND_Y - getHillTop(mConfig);
        const mHP = clamp01((GROUND_Y - machine.y) / Math.max(1, mHillHeight));
        const mScale = (1.05 - mHP * 0.35) * lerp(0.70, 1.35, mDepth);
        drawMachine(machine, mScale);
      } else {
        drawMachine(machine);
      }
    }
  }

  // Draw floaters
  drawFloaters();
}

// Game loop
let lastFrameTime = 0;
let tickAccum = 0;
const TICK_MS = 1000 / 60;

function gameLoop(timestamp) {
  if (lastFrameTime === 0) lastFrameTime = timestamp;
  let elapsed = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  if (elapsed > 200) elapsed = 200;

  tickAccum += elapsed;
  while (tickAccum >= TICK_MS) {
    for (const key in sheepState) updateSheep(sheepState[key]);
    updatePeasants();
    updateMachines();
    updateCropGrowth();
    updateFloaters();
    tickAccum -= TICK_MS;
  }

  render();
  requestAnimationFrame(gameLoop);
}

/** Display the popup menu for a hill */
function showPopup(hillNum) {
  const config = hillConfigs[hillNum];
  const houseCount = (game.houses[hillNum] || []).length;
  const landNames = { farm: 'Farm', commons: 'Commons', forest: 'Forest', cleared: 'Cleared Land' };
  DOM.popupTitle.textContent = `Hill ${hillNum} - ${landNames[config.landType] || config.landType}`;
  let html = `<p>üè† Houses: ${houseCount}/5</p>`;
  if (VISIBLE_HILLS.includes(hillNum)) {
    if (houseCount < 5) html += `<button class="popup-btn build" onclick="buildCottage(${hillNum})">Build Cottage (¬£${COSTS.house})</button>`;
    if (houseCount > 0 && game.enclosureUnlocked) html += `<button class="popup-btn build" onclick="demolishHouse(${hillNum})">Demolish Cottage (+¬£${COSTS.demolishReward})</button>`;
    if (config.landType === 'forest') html += `<button class="popup-btn clear" onclick="clearLand(${hillNum})">Clear Land (¬£${COSTS.clearLand})</button>`;
    if (config.landType === 'cleared') {
      html += `<button class="popup-btn farm" onclick="buildFarm(${hillNum})">Build Farm (¬£${COSTS.buildFarm})</button>`;
      html += `<button class="popup-btn commons" onclick="buildCommons(${hillNum})">Make Commons (¬£${COSTS.buildCommons})</button>`;
    }
    if (config.landType === 'commons' && game.enclosureUnlocked) {
      html += `<button class="popup-btn farm" onclick="convertCommonsToFarm(${hillNum})">Convert to Farm (¬£${COSTS.buildFarm})</button>`;
    }
  } else {
    html += `<p><em>This hill is too far away</em></p>`;
  }
  if (config.landType === 'farm') {
    const health = config.soilHealth !== undefined ? config.soilHealth : 100;
    const healthColor = health > 60 ? '#4CAF50' : health > 30 ? '#FF9800' : '#F44336';
    const playerRows = (config.rowOwnership || []).filter(r => r === 'player').length;
    const peasantRows = (config.rowOwnership || []).filter(r => r === 'peasant').length;
    html += `<p style="margin-top:10px">üå± Crop: <strong>${config.cropType || 'wheat'}</strong></p>`;
    html += `<p style="margin:6px 0"><strong>Your rows:</strong> ${playerRows} &nbsp;|&nbsp; <strong>Peasant rows:</strong> ${peasantRows}</p>`;
    html += `<p>Soil Health: <span style="color:${healthColor};font-weight:bold">${Math.round(health)}%</span></p>`;
    html += `<div style="background:#ddd;border-radius:4px;height:8px;margin:4px 0 8px"><div style="background:${healthColor};height:100%;width:${health}%;border-radius:4px"></div></div>`;
    if (config.isFallow) {
      const daysLeft = Math.max(0, 10 - (game.day - (config.fallowStartDay || game.day)));
      html += `<p><em>Field is fallow (${daysLeft} days left)</em></p>`;
      html += `<button class="popup-btn farm" onclick="endFallow(${hillNum})">End Fallow Early</button>`;
    } else {
      const crops = game.turnipsUnlocked ? ['wheat', 'cabbage', 'turnip'] : ['wheat', 'cabbage'];
      const otherCrops = crops.filter(c => c !== (config.cropType || 'wheat'));
      const restoreLabel = game.turnipsUnlocked ? '90%' : '50%';
      for (const crop of otherCrops) {
        html += `<button class="popup-btn farm" onclick="changeCrop(${hillNum},'${crop}')">Switch to ${crop} (+${restoreLabel} soil)</button>`;
      }
      html += `<button class="popup-btn clear" onclick="setFallow(${hillNum})">Set Fallow (restores soil in 10 days)</button>`;
    }
    if (playerRows > 0) {
      html += `<button class="popup-btn clear" onclick="giveRowToPeasants(${hillNum})" style="margin-top:6px">Give a Row to Peasants</button>`;
      html += `<p style="font-size:11px;color:#c0392b;margin:2px 0 6px"><em>‚ö† Warning: giving land to peasants is permanent and cannot be undone.</em></p>`;
    }
    html += `<p style="font-size:11px;color:#666;margin-top:8px"><em>Harvesting depletes soil. Switch crops or fallow to restore. Low soil = slow growth & fast rot.</em></p>`;
    if (game.mechanicsUnlocked) {
      const machineCount = game.machines.filter(m => m.homeHill === hillNum).length;
      html += `<p style="margin-top:8px">\u2699 Machines on this farm: ${machineCount}</p>`;
      html += `<button class="popup-btn build" onclick="buyMachine(${hillNum})">Buy Seed Drill (\u00a3${COSTS.machine})</button>`;
    }
    if (game.enclosureUnlocked && !config.enclosed) {
      html += `<button class="popup-btn clear" onclick="encloseField(${hillNum})" style="margin-top:6px">Enclose Field (\u00a3${COSTS.encloseField})</button>`;
      html += `<p style="font-size:11px;color:#c0392b;margin:2px 0 6px"><em>\u26a0 Removes all peasant rows and bars peasants from this field.</em></p>`;
    }
    if (config.enclosed) {
      html += `<p style="margin-top:6px;color:#8B4513"><strong>\ud83d\udd12 Enclosed</strong> \u2014 peasants barred from entry</p>`;
    }
  }
  html += `<button class="popup-btn close" onclick="closePopup()">Close</button>`;
  DOM.popupInfo.innerHTML = html;
  DOM.hillPopup.classList.add('show');
  DOM.popupOverlay.classList.add('show');
}

/** Close the popup menu */
function closePopup() {
  DOM.hillPopup.classList.remove('show');
  DOM.popupOverlay.classList.remove('show');
}

window.buildCottage = function(hillNum) {
  if (!spend(COSTS.house)) return;
  if (!game.houses[hillNum]) game.houses[hillNum] = [];
  if (game.houses[hillNum].length >= 5) return;
  const house = createHouse(hillNum, hillConfigs[hillNum]);
  if (house) {
    game.houses[hillNum].push(house);
    updatePeasantCount();
  }
  closePopup();
};

window.clearLand = function(hillNum) {
  if (!spend(COSTS.clearLand)) return;
  hillConfigs[hillNum].landType = 'cleared';
  hillConfigs[hillNum].color = '#8B7355';
  delete hillFeatures[hillNum];
  closePopup();
};

window.buildFarm = function(hillNum) {
  if (!spend(COSTS.buildFarm)) return;
  hillConfigs[hillNum].landType = 'farm';
  hillConfigs[hillNum].color = '#6B5D3F';
  hillConfigs[hillNum].cropType = 'wheat';
  initializeFarmHill(hillConfigs[hillNum]);
  closePopup();
};

window.buildCommons = function(hillNum) {
  if (!spend(COSTS.buildCommons)) return;
  hillConfigs[hillNum].landType = 'commons';
  hillConfigs[hillNum].color = '#7CB342';
  sheepState[hillNum] = initializeSheep(hillNum, hillConfigs[hillNum]);
  closePopup();
};

window.giveRowToPeasants = function(hillNum) {
  const config = hillConfigs[hillNum];
  if (!config.rowOwnership) return;
  const idx = config.rowOwnership.indexOf('player');
  if (idx === -1) return;
  config.rowOwnership[idx] = 'peasant';
  addLogMessage('You gave a row of land to the peasants');
  showPopup(hillNum);
};

window.buyMachine = function(hillNum) {
  if (!spend(COSTS.machine)) return;
  const machine = createMachine(hillNum);
  game.machines.push(machine);
  addLogMessage('Seed drill purchased!');
  closePopup();
};

window.convertCommonsToFarm = function(hillNum) {
  if (!spend(COSTS.buildFarm)) return;
  hillConfigs[hillNum].landType = 'farm';
  hillConfigs[hillNum].color = '#6B5D3F';
  hillConfigs[hillNum].cropType = 'wheat';
  delete sheepState[hillNum];
  initializeFarmHill(hillConfigs[hillNum]);
  addLogMessage('Commons converted to farmland');
  closePopup();
};

window.encloseField = function(hillNum) {
  if (!spend(COSTS.encloseField)) return;
  const config = hillConfigs[hillNum];
  config.enclosed = true;
  if (config.rowOwnership) {
    for (let i = 0; i < config.rowOwnership.length; i++) {
      config.rowOwnership[i] = 'player';
    }
  }
  for (const p of game.peasants) {
    if (p.workHill === hillNum) {
      goHome(p);
    }
  }
  addLogMessage('Field enclosed \u2014 peasants barred from entry');
  closePopup();
};

window.demolishHouse = function(hillNum) {
  const houses = game.houses[hillNum];
  if (!houses || houses.length === 0) return;
  game.money += 10;
  updateUI();
  const removedIdx = houses.length - 1;
  houses.pop();
  game.peasants = game.peasants.filter(p => !(p.homeHill === Number(hillNum) && p.houseIdx === removedIdx));
  updatePeasantCount();
  addLogMessage('Cottage demolished for +\u00a310');
  closePopup();
};

window.changeCrop = function(hillNum, newCrop) {
  const config = hillConfigs[hillNum];
  config.cropType = newCrop;
  const deficit = 100 - (config.soilHealth || 100);
  const restorePct = game.turnipsUnlocked ? 0.9 : 0.5;
  config.soilHealth = Math.min(100, (config.soilHealth || 100) + deficit * restorePct);
  if (config.rowNodes) {
    for (const rowIdx in config.rowNodes) {
      for (const node of config.rowNodes[rowIdx]) {
        node.hasCrop = false;
        node.crop = null;
      }
    }
  }
  addLogMessage(`Switched to ${newCrop} \u2014 soil restored`);
  closePopup();
};

window.setFallow = function(hillNum) {
  const config = hillConfigs[hillNum];
  config.isFallow = true;
  config.fallowStartDay = game.day;
  config.color = '#9E8E6E';
  if (config.rowNodes) {
    for (const rowIdx in config.rowNodes) {
      for (const node of config.rowNodes[rowIdx]) {
        node.hasCrop = false;
        node.crop = null;
      }
    }
  }
  addLogMessage('Field set fallow \u2014 soil will restore in 10 days');
  closePopup();
};

window.endFallow = function(hillNum) {
  const config = hillConfigs[hillNum];
  const daysFallow = game.day - (config.fallowStartDay || game.day);
  const restorationPct = Math.min(1, daysFallow / 10);
  const deficit = 100 - (config.soilHealth || 100);
  config.soilHealth = Math.min(100, (config.soilHealth || 100) + deficit * restorationPct);
  config.isFallow = false;
  config.fallowStartDay = null;
  config.color = '#6B5D3F';
  addLogMessage('Fallow ended early \u2014 soil partially restored');
  closePopup();
};

/** Show day 40 newspaper announcing turnips */
function showNewspaper() {
  game.turnipsUnlocked = true;
  DOM.popupTitle.textContent = '\ud83d\udcf0 THE VILLAGE GAZETTE';
  DOM.popupInfo.innerHTML = `
    <div style="text-align:left;border:2px solid #1c1410;padding:12px;margin:8px 0;font-family:Georgia,serif">
      <p style="font-size:11px;color:#666;text-align:center">Day 40</p>
      <h3 style="text-align:center;border-bottom:2px solid #1c1410;padding-bottom:6px;margin-bottom:8px">AGRICULTURAL BREAKTHROUGH!</h3>
      <p style="font-size:13px;line-height:1.5">Local farmers have discovered the mighty <strong>turnip</strong>! This hardy root vegetable, when used in crop rotation, restores <strong>90%</strong> of depleted soil health &mdash; far superior to the mere 50% from switching between wheat and cabbage.</p>
      <p style="font-size:13px;line-height:1.5;margin-top:8px">Additionally, improved farming techniques have <strong>doubled all crop yields</strong>!</p>
      <p style="font-size:13px;line-height:1.5;margin-top:8px">Scholars advise rotating between all three crops for maximum soil vitality.</p>
    </div>
    <button class="popup-btn build" onclick="closePopup()">Splendid!</button>
  `;
  DOM.hillPopup.classList.add('show');
  DOM.popupOverlay.classList.add('show');
}

/** Show day 80 newspaper announcing machines */
function showMechanicsNewspaper() {
  game.mechanicsUnlocked = true;
  DOM.popupTitle.textContent = '\ud83d\udcf0 THE VILLAGE GAZETTE';
  DOM.popupInfo.innerHTML = `
    <div style="text-align:left;border:2px solid #1c1410;padding:12px;margin:8px 0;font-family:Georgia,serif">
      <p style="font-size:11px;color:#666;text-align:center">Day 80</p>
      <h3 style="text-align:center;border-bottom:2px solid #1c1410;padding-bottom:6px;margin-bottom:8px">MECHANICAL REVOLUTION!</h3>
      <p style="font-size:13px;line-height:1.5">Ingenious craftsmen have perfected the <strong>seed drill</strong> and <strong>mechanical reaper</strong>! These marvellous machines can plant and harvest <strong>three rows at once</strong>, working faster than any peasant.</p>
      <p style="font-size:13px;line-height:1.5;margin-top:8px">Machines may be purchased for <strong>\u00a340</strong> on any farm hill.</p>
    </div>
    <button class="popup-btn build" onclick="closePopup()">Remarkable!</button>
  `;
  DOM.hillPopup.classList.add('show');
  DOM.popupOverlay.classList.add('show');
}

/** Show day 120 newspaper announcing enclosure acts */
function showEnclosureNewspaper() {
  game.enclosureUnlocked = true;
  DOM.popupTitle.textContent = '\ud83d\udcf0 THE VILLAGE GAZETTE';
  DOM.popupInfo.innerHTML = `
    <div style="text-align:left;border:2px solid #1c1410;padding:12px;margin:8px 0;font-family:Georgia,serif">
      <p style="font-size:11px;color:#666;text-align:center">Day 120</p>
      <h3 style="text-align:center;border-bottom:2px solid #1c1410;padding-bottom:6px;margin-bottom:8px">THE ENCLOSURE ACTS</h3>
      <p style="font-size:13px;line-height:1.5">The good men in Parliament have, in their wisdom, passed the <strong>Enclosure Acts</strong>. Landowners may now:</p>
      <ul style="font-size:13px;line-height:1.8;margin:8px 0 8px 20px;text-align:left">
        <li>Convert <strong>commons</strong> into farmland (\u00a325)</li>
        <li><strong>Enclose</strong> fields with fencing, removing peasant strips (\u00a325)</li>
        <li><strong>Demolish</strong> peasant cottages (+\u00a310)</li>
      </ul>
      <p style="font-size:13px;line-height:1.5">The peasantry are said to be most displeased.</p>
    </div>
    <button class="popup-btn build" onclick="closePopup()">So be it.</button>
  `;
  DOM.hillPopup.classList.add('show');
  DOM.popupOverlay.classList.add('show');
}

window.closePopup = closePopup;

// Input
function setupInput() {
  const viewport = document.getElementById('viewport');
  const canvas = document.getElementById('gameCanvas');
  let isDown = false, startX = 0, scrollLeft = 0, hasMoved = false;

  viewport.addEventListener('mousedown', (e) => {
    isDown = true;
    hasMoved = false;
    startX = e.pageX - viewport.offsetLeft;
    scrollLeft = viewport.scrollLeft;
  });
  viewport.addEventListener('mouseleave', () => { isDown = false; });
  viewport.addEventListener('mouseup', () => { isDown = false; });
  viewport.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    hasMoved = true;
    viewport.scrollLeft = scrollLeft - (e.pageX - viewport.offsetLeft - startX) * 2;
  });

  canvas.addEventListener('click', (e) => {
    if (hasMoved) return;
    const rect = canvas.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
    // Check hills front to back (reverse of render order) for click detection
    for (let i = sortedHillKeys.length - 1; i >= 0; i--) {
      const hillNum = sortedHillKeys[i];
      if (ctx.isPointInPath(ALL_HILL_PATHS[hillNum], canvasX, canvasY)) {
        showPopup(hillNum);
        return;
      }
    }
  });

  document.getElementById('popupOverlay').addEventListener('click', closePopup);
}

let gameStarted = false;

/** Start the game from the title screen */
window.startGame = function() {
  DOM.titleScreen.classList.add('hidden');
  DOM.hud.classList.remove('hidden');
  DOM.dayIndicator.classList.remove('hidden');
  gameStarted = true;
  requestAnimationFrame(gameLoop);
};

/** Initialize the game - set up canvas, paths, starting state */
function init() {
  // Cache DOM element references for performance
  DOM.canvas = document.getElementById('gameCanvas');
  DOM.moneyVal = document.getElementById('moneyVal');
  DOM.foodVal = document.getElementById('foodVal');
  DOM.peasantVal = document.getElementById('peasantVal');
  DOM.capacityVal = document.getElementById('capacityVal');
  DOM.dayVal = document.getElementById('dayVal');
  DOM.hud = document.getElementById('hud');
  DOM.dayIndicator = document.getElementById('day-indicator');
  DOM.titleScreen = document.getElementById('title-screen');
  DOM.viewport = document.getElementById('viewport');
  DOM.hillPopup = document.getElementById('hillPopup');
  DOM.popupOverlay = document.getElementById('popupOverlay');
  DOM.popupTitle = document.getElementById('popupTitle');
  DOM.popupInfo = document.getElementById('popupInfo');
  DOM.gameLog = document.getElementById('game-log');

  ctx = DOM.canvas.getContext('2d');

  // Pre-generate all hill paths
  for (const key in hillConfigs) {
    ALL_HILL_PATHS[key] = new Path2D(generateHillPath(Number(key), hillConfigs[key]));
  }

  // Cache sorted hill keys for rendering (back to front by depth)
  sortedHillKeys = Object.keys(hillConfigs).map(Number);
  sortedHillKeys.sort((a, b) => getHillTop(hillConfigs[a]) - getHillTop(hillConfigs[b]));

  for (const key in hillConfigs) {
    const config = hillConfigs[key];
    if (config.landType === 'farm') initializeFarmHill(config);
    if (config.landType === 'commons') sheepState[key] = initializeSheep(Number(key), config);
  }

  // Pre-plant first row of hill 11 at ready stage
  const starterNodes = getRowNodes(11, 0);
  for (const node of starterNodes) {
    node.hasCrop = true;
    node.crop = { stage: 'ready', growthTimer: 0, rotTimer: 0 };
  }

  // Starter houses
  for (const hillNum of [11]) {
    if (!VISIBLE_HILLS.includes(hillNum)) continue;
    if (!game.houses[hillNum]) game.houses[hillNum] = [];
    const house = createHouse(hillNum, hillConfigs[hillNum]);
    if (house) game.houses[hillNum].push(house);
  }

  updatePeasantCount();
  updateUI();
  setupInput();

  DOM.viewport.scrollLeft = (DOM.viewport.scrollWidth - DOM.viewport.clientWidth) / 2;

  // Render initial frame but don't start game loop until player clicks Begin
  render();
}

window.addEventListener('load', init);
</script>
</body>
</html>
